{"ast":null,"code":"import _defineProperty from \"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _objectSpread from \"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\nvar _HIGHLIGHT_MODE;\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".JSXElement.JSXIdentifier{color:#4169e1}.JSXElement.JSXBracket{color:#ff8c00}.JSXElement.JSXText{color:#b8860b}.JSXElement.JSXGlyph{background:cyan;opacity:.25}.JSXClosingFragment.JSXBracket,.JSXOpeningElement.JSXBracket,.JSXOpeningFragment.JSXBracket{color:#ff8c00;font-weight:700}.JSXOpeningElement.JSXIdentifier{color:#4169e1}.JSXClosingElement.JSXBracket{color:#ff8c00;font-weight:lighter}.JSXClosingElement.JSXIdentifier{color:#4169e1;font-weight:lighter}.JSXAttribute.JSXIdentifier{color:#4682b4}.JSXExpressionContainer.JSXBracket,.JSXSpreadAttribute.JSXBracket,.JSXSpreadChild.JSXBracket{color:#ff8c00}\";\nstyleInject(css_248z);\n\nvar collectJSXExpressions = function collectJSXExpressions(ast, traverse) {\n  var traverseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var jsxExpressions = [];\n\n  var enter = function enter(path) {\n    if (path.type.toUpperCase().includes(\"JSX\")) {\n      jsxExpressions.push(path);\n    }\n  };\n\n  traverse(ast, _objectSpread(_objectSpread({}, traverseOptions), {}, {\n    enter: enter\n  }));\n  return jsxExpressions;\n};\n\nvar isJSXIdentifier = function isJSXIdentifier(path) {\n  return path && (path.key === 'object' || path.key === 'property' || path.key === 'name' || path.key === 'namespace');\n};\n\nvar isParentJSXAttribute = function isParentJSXAttribute(path) {\n  return path && path.parentPath && path.parentPath.isJSXAttribute();\n};\n\nvar getLoc = function getLoc(path) {\n  return path && path.node && path.node.loc;\n};\n\nvar cloneLoc = function cloneLoc(path) {\n  var loc = getLoc(path);\n\n  if (!loc) {\n    return null;\n  }\n\n  return {\n    start: _objectSpread({}, loc.start),\n    end: _objectSpread({}, loc.end)\n  };\n};\n\nvar getCuratedLoc = function getCuratedLoc(path) {\n  var loc = cloneLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  if (path.key === 'object' && path.container) {\n    loc.end = _objectSpread({}, path.container.property.loc.start);\n  }\n\n  return loc;\n};\n\nvar extractJSXOpeningElement = function extractJSXOpeningElement(path) {\n  var loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  var openingElement = path.node.openingElement;\n\n  if (!openingElement) {\n    return [null, null, null, null];\n  }\n\n  var elementName = openingElement.name.name;\n  var startLoc = {\n    start: _objectSpread({}, openingElement.loc.start),\n    end: _objectSpread({}, openingElement.name.loc.start)\n  };\n  var endLoc = {\n    start: _objectSpread({}, openingElement.loc.end),\n    end: _objectSpread({}, openingElement.loc.end)\n  };\n  endLoc.start.column--;\n\n  if (openingElement.selfClosing) {\n    endLoc.start.column--;\n  }\n\n  return [openingElement, elementName, startLoc, endLoc];\n};\n\nvar extractJSXClosingElement = function extractJSXClosingElement(path) {\n  var loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  var closingElement = path.node.closingElement;\n\n  if (!closingElement) {\n    return [null, null, null, null];\n  }\n\n  var elementName = closingElement.name && closingElement.name.name;\n  var startLoc = {\n    start: _objectSpread({}, closingElement.loc.start),\n    end: _objectSpread({}, closingElement.name.loc.start)\n  };\n  var endLoc = {\n    start: _objectSpread({}, closingElement.loc.end),\n    end: _objectSpread({}, closingElement.loc.end)\n  };\n  endLoc.start.column--;\n  return [closingElement, elementName, startLoc, endLoc];\n};\n\nvar extractJSXExpressionEdges = function extractJSXExpressionEdges(path) {\n  var loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  var innerNode = null;\n  var innerLocKey = path.isJSXSpreadChild() ? 'expression' : path.isJSXSpreadAttribute() ? 'argument' : null;\n  var innerLoc = null;\n\n  if (innerLocKey) {\n    innerNode = path.node[innerLocKey];\n    innerLoc = {\n      start: _objectSpread({}, innerNode.loc.start),\n      end: _objectSpread({}, innerNode.loc.end)\n    };\n\n    if (innerNode.extra && innerNode.extra.parenthesized) {\n      innerLoc.start.column--;\n      innerLoc.end.column++;\n    }\n  } else {\n    innerLoc = {\n      start: _objectSpread({}, loc.start),\n      end: _objectSpread({}, loc.end)\n    };\n    innerLoc.start.column++;\n    innerLoc.end.column--;\n  }\n\n  var startEdgeLoc = {\n    start: _objectSpread({}, loc.start),\n    end: _objectSpread({}, innerLoc.start)\n  };\n  var endEdgeLoc = {\n    start: _objectSpread({}, innerLoc.end),\n    end: _objectSpread({}, loc.end)\n  };\n  return [innerNode, innerLocKey, startEdgeLoc, endEdgeLoc];\n};\n\nvar COMMENT_ACTION_ID = \"editor.action.commentLine\";\n\nvar configureLoc2Range = function configureLoc2Range(monaco) {\n  var parserType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'babel';\n\n  switch (parserType) {\n    case 'babel':\n    default:\n      return function (loc) {\n        var startLineOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var startColumnOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var endLineOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var endColumnOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n        if (!loc || !loc.start) {\n          return new monaco.Range(1, 1, 1, 1);\n        }\n\n        return new monaco.Range(startLineOffset + loc.start.line, startColumnOffset + loc.start.column + 1, endLineOffset + loc.end ? loc.end.line : loc.start.line, endColumnOffset + loc.end ? loc.end.column + 1 : loc.start.column + 1);\n      };\n  }\n};\n\nvar configureRange2Loc = function configureRange2Loc() {\n  var parserType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'babel';\n\n  switch (parserType) {\n    case 'babel':\n    default:\n      return function (rangeOrPosition) {\n        var startLineOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var startColumnOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var endLineOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var endColumnOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        var loc = {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        };\n\n        if (!rangeOrPosition) {\n          return loc;\n        }\n\n        if (rangeOrPosition.lineNumber) {\n          loc.start.line = startLineOffset + rangeOrPosition.lineNumber;\n          loc.start.column = startColumnOffset + rangeOrPosition.column - 1;\n          loc.end.line = endLineOffset + rangeOrPosition.lineNumber;\n          loc.end.column = endColumnOffset + rangeOrPosition.column - 1;\n        } else {\n          loc.start.line = startLineOffset + rangeOrPosition.startLineNumber;\n          loc.start.column = startColumnOffset + rangeOrPosition.startColumn - 1;\n          loc.end.line = endLineOffset + rangeOrPosition.endLineNumber;\n          loc.end.column = endColumnOffset + rangeOrPosition.endColumn - 1;\n        }\n\n        return loc;\n      };\n  }\n};\n\nvar MonacoEditorManager = function MonacoEditorManager(monacoEditor, monaco, loc2Range) {\n  var _this = this;\n\n  _classCallCheck(this, MonacoEditorManager);\n\n  this.monacoEditor = monacoEditor;\n  this.monaco = monaco;\n  this.loc2Range = loc2Range || configureRange2Loc(monaco);\n\n  this.runEditorCommentLineAction = function () {\n    return _this.monacoEditor.getAction(COMMENT_ACTION_ID).run();\n  };\n\n  this.getLineIndentationColumn = function (lineNumber) {\n    return _this.monacoEditor.getModel().getLineFirstNonWhitespaceColumn(lineNumber);\n  };\n\n  this.getCommentableStartingRange = function (range) {\n    var startColumn = _this.getLineIndentationColumn(range.startLineNumber);\n\n    var commentableRange = new _this.monaco.Range(range.startLineNumber, startColumn, range.startLineNumber, startColumn);\n    return commentableRange;\n  };\n\n  this.getCommentContainingStartingRange = function (range) {\n    var startColumn = _this.getLineIndentationColumn(range.startLineNumber);\n\n    startColumn = startColumn ? startColumn - 1 : 0;\n    var containingRange = new _this.monaco.Range(range.startLineNumber, startColumn, range.startLineNumber, startColumn);\n    return containingRange;\n  };\n\n  this.getSelectionFirstLineText = function () {\n    var model = _this.monacoEditor.getModel();\n\n    var _this$monacoEditor$ge = _this.monacoEditor.getSelection(),\n        startLineNumber = _this$monacoEditor$ge.startLineNumber;\n\n    var jsCommentRange = new _this.monaco.Range(startLineNumber, _this.getLineIndentationColumn(startLineNumber), startLineNumber, model.getLineMaxColumn(startLineNumber));\n    return model.getValueInRange(jsCommentRange);\n  };\n};\n\nvar prepareOptions = function prepareOptions(path) {\n  var jsxTypeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var highlighterOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return highlighterOptions.iShowHover ? _objectSpread(_objectSpread({}, jsxTypeOptions), {\n    hoverMessage: \"(\".concat(path.type, \")\")\n  }) : jsxTypeOptions;\n};\n\nvar HIGHLIGHT_TYPE = {\n  ELEMENT: 'ELEMENT',\n  ALL: 'ALL',\n  IDENTIFIER: 'IDENTIFIER',\n  EDGE: 'EDGE',\n  STYLE: 'STYLE'\n};\nvar HIGHLIGHT_MODE = (_HIGHLIGHT_MODE = {}, _defineProperty(_HIGHLIGHT_MODE, HIGHLIGHT_TYPE.ELEMENT, function (path, jsxTypeOptions, highlighterOptions) {\n  var _extractJSXOpeningEle = extractJSXOpeningElement(path),\n      _extractJSXOpeningEle2 = _slicedToArray(_extractJSXOpeningEle, 4),\n      openingElement = _extractJSXOpeningEle2[0],\n      elementName = _extractJSXOpeningEle2[1],\n      startLoc = _extractJSXOpeningEle2[2],\n      endLoc = _extractJSXOpeningEle2[3];\n\n  var result = [];\n\n  if (openingElement) {\n    result.push([startLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.openingElementOptions : JSXTypes.JSXBracket.options]);\n    result.push([endLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.openingElementOptions : JSXTypes.JSXBracket.options]);\n  }\n\n  var _extractJSXClosingEle = extractJSXClosingElement(path),\n      _extractJSXClosingEle2 = _slicedToArray(_extractJSXClosingEle, 4),\n      closingElement = _extractJSXClosingEle2[0],\n      closingElementStartLoc = _extractJSXClosingEle2[2],\n      closingElementEndLoc = _extractJSXClosingEle2[3];\n\n  if (closingElement) {\n    result.push([closingElementStartLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.closingElementOptions : JSXTypes.JSXBracket.options]);\n    result.push([closingElementEndLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.closingElementOptions : JSXTypes.JSXBracket.options]);\n  }\n\n  var loc = getLoc(path);\n  highlighterOptions.isHighlightGlyph && result.push([loc, JSXTypes.JSXElement.options(elementName)]);\n  return result;\n}), _defineProperty(_HIGHLIGHT_MODE, HIGHLIGHT_TYPE.ALL, function (path, jsxTypeOptions, highlighterOptions) {\n  var curatedLoc = getCuratedLoc(path);\n  var result = [];\n  curatedLoc && result.push([curatedLoc, prepareOptions(path, jsxTypeOptions, highlighterOptions)]);\n  return result;\n}), _defineProperty(_HIGHLIGHT_MODE, HIGHLIGHT_TYPE.IDENTIFIER, function (path, jsxTypeOptions, highlighterOptions) {\n  if (!isJSXIdentifier(path)) {\n    return [];\n  }\n\n  return HIGHLIGHT_MODE[HIGHLIGHT_TYPE.ALL](path, isParentJSXAttribute(path) ? JSXTypes.JSXAttribute.options : jsxTypeOptions, highlighterOptions);\n}), _defineProperty(_HIGHLIGHT_MODE, HIGHLIGHT_TYPE.EDGE, function (path, jsxTypeOptions, highlighterOptions) {\n  var options = prepareOptions(path, jsxTypeOptions, highlighterOptions);\n\n  var _extractJSXExpression = extractJSXExpressionEdges(path),\n      _extractJSXExpression2 = _slicedToArray(_extractJSXExpression, 4),\n      startEdgeLoc = _extractJSXExpression2[2],\n      endEdgeLoc = _extractJSXExpression2[3];\n\n  var result = [];\n  result.push([startEdgeLoc, options]);\n  result.push([endEdgeLoc, options]);\n  return result;\n}), _defineProperty(_HIGHLIGHT_MODE, HIGHLIGHT_TYPE.STYLE, function () {\n  return [];\n}), _HIGHLIGHT_MODE);\nvar JSXTypes = {\n  JSXIdentifier: {\n    highlightScope: HIGHLIGHT_TYPE.IDENTIFIER,\n    options: {\n      inlineClassName: 'JSXElement.JSXIdentifier'\n    }\n  },\n  JSXOpeningFragment: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXOpeningFragment.JSXBracket'\n    }\n  },\n  JSXClosingFragment: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXClosingFragment.JSXBracket'\n    }\n  },\n  JSXText: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXElement.JSXText'\n    }\n  },\n  JSXExpressionContainer: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXExpressionContainer.JSXBracket'\n    }\n  },\n  JSXSpreadChild: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXSpreadChild.JSXBracket'\n    }\n  },\n  JSXSpreadAttribute: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXSpreadAttribute.JSXBracket'\n    }\n  },\n  JSXElement: {\n    highlightScope: HIGHLIGHT_TYPE.ELEMENT,\n    options: function options(elementName) {\n      return {\n        glyphMarginClassName: 'JSXElement.JSXGlyph',\n        glyphMarginHoverMessage: \"JSX Element\".concat(elementName ? ': ' + elementName : '')\n      };\n    }\n  },\n  JSXBracket: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXElement.JSXBracket'\n    },\n    openingElementOptions: {\n      inlineClassName: 'JSXOpeningElement.JSXBracket'\n    },\n    closingElementOptions: {\n      inlineClassName: 'JSXClosingElement.JSXBracket'\n    }\n  },\n  JSXOpeningElement: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXOpeningElement.JSXIdentifier'\n    }\n  },\n  JSXClosingElement: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXClosingElement.JSXIdentifier'\n    }\n  },\n  JSXAttribute: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXAttribute.JSXIdentifier'\n    }\n  }\n};\n\nvar DecoratorMapper = function DecoratorMapper(monacoEditor, loc2Range) {\n  var _JSXTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : JSXTypes;\n\n  _classCallCheck(this, DecoratorMapper);\n\n  var decorators = [];\n  var jsxDecoratorIds = [];\n\n  var addDecorator = function addDecorator(_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        loc = _ref2[0],\n        options = _ref2[1];\n\n    return decorators.push({\n      range: loc2Range(loc),\n      options: options\n    });\n  };\n\n  var deltaDecorations = function deltaDecorations() {\n    jsxDecoratorIds = monacoEditor.deltaDecorations(jsxDecoratorIds || [], decorators);\n    decorators = [];\n    return jsxDecoratorIds;\n  };\n\n  this.deltaJSXDecorations = function (jsxExpressions, options) {\n    var _loop = function _loop(jsxType) {\n      jsxExpressions.filter(function (path) {\n        return path.type === jsxType;\n      }).forEach(function (path) {\n        return HIGHLIGHT_MODE[_JSXTypes[jsxType].highlightScope](path, _JSXTypes[jsxType].options, options).forEach(function (entry) {\n          return addDecorator(entry);\n        });\n      });\n    };\n\n    for (var jsxType in _JSXTypes) {\n      _loop(jsxType);\n    }\n\n    return deltaDecorations();\n  };\n\n  this.reset = function () {\n    decorators = [];\n    deltaDecorations();\n  };\n\n  this.reset();\n};\n\nvar JSXCommentContexts = {\n  JS: 'JS',\n  JSX: 'JSX'\n};\n\nfunction getJSXContext(jsxExpressions, commentableRange, commentContainingRange, loc2Range) {\n  if (!(jsxExpressions && commentableRange && commentContainingRange && loc2Range)) {\n    return JSXCommentContexts.JS;\n  }\n\n  var minRange = null;\n  var minCommentableRange = null;\n  var path = null;\n  var commentablePath = null;\n  jsxExpressions.forEach(function (p) {\n    var jsxRange = loc2Range(p.node.loc);\n\n    if ((p.key === 'name' || p.key === 'property') && p.isJSXIdentifier() && jsxRange.intersectRanges(commentableRange)) {\n      if (!minCommentableRange || minCommentableRange.containsRange(jsxRange)) {\n        minCommentableRange = jsxRange;\n        commentablePath = p;\n      }\n    }\n\n    if (jsxRange.intersectRanges(commentContainingRange)) {\n      if (!minRange || minRange.containsRange(jsxRange)) {\n        minRange = jsxRange;\n        path = p;\n      }\n    }\n  });\n\n  if (!path || path.isJSXExpressionContainer() || commentablePath) {\n    return JSXCommentContexts.JS;\n  } else {\n    return JSXCommentContexts.JSX;\n  }\n}\n\nvar Commenter = function Commenter(monacoEditorManager, parseJSXExpressionsPromise) {\n  var _this2 = this;\n\n  _classCallCheck(this, Commenter);\n\n  var _editorCommandId = null;\n\n  this.getEditorCommandId = function () {\n    return _editorCommandId;\n  };\n\n  var _isJSXCommentCommandActive = false;\n\n  this.isJSXCommentCommandActive = function () {\n    return _isJSXCommentCommandActive;\n  };\n\n  var editorCommandOnDispose = function editorCommandOnDispose() {\n    _isJSXCommentCommandActive = false;\n  };\n\n  this.runJsxCommentAction = function (selection, commentContext) {\n    var monacoEditor = monacoEditorManager.monacoEditor,\n        monaco = monacoEditorManager.monaco,\n        runEditorCommentLineAction = monacoEditorManager.runEditorCommentLineAction,\n        getSelectionFirstLineText = monacoEditorManager.getSelectionFirstLineText;\n    var jsCommentText = getSelectionFirstLineText();\n\n    if (jsCommentText.match(/^\\s*\\/[/*]/)) {\n      runEditorCommentLineAction();\n      return;\n    }\n\n    var model = monacoEditor.getModel();\n    var isUnCommentAction = true;\n    var commentsData = [];\n\n    for (var i = selection.startLineNumber; i <= selection.endLineNumber; i++) {\n      var commentRange = new monaco.Range(i, model.getLineFirstNonWhitespaceColumn(i), i, model.getLineMaxColumn(i));\n      var commentText = model.getValueInRange(commentRange);\n      commentsData.push({\n        commentRange: commentRange,\n        commentText: commentText\n      });\n      isUnCommentAction = isUnCommentAction && !!commentText.match(/{\\/\\*/);\n    }\n\n    if (commentContext !== JSXCommentContexts.JSX && !isUnCommentAction) {\n      runEditorCommentLineAction();\n      return;\n    }\n\n    var editOperations = [];\n    var commentsDataIndex = 0;\n\n    for (var _i = selection.startLineNumber; _i <= selection.endLineNumber; _i++) {\n      var _commentsData$comment = commentsData[commentsDataIndex++],\n          _commentText = _commentsData$comment.commentText,\n          _commentRange = _commentsData$comment.commentRange;\n\n      if (isUnCommentAction) {\n        _commentText = _commentText.replace(/{\\/\\*/, '');\n        _commentText = _commentText.replace(/\\*\\/}/, '');\n      } else {\n        _commentText = \"{/*\".concat(_commentText, \"*/}\");\n      }\n\n      editOperations.push({\n        identifier: {\n          major: 1,\n          minor: 1\n        },\n        range: _commentRange,\n        text: _commentText,\n        forceMoveMarkers: true\n      });\n    }\n\n    editOperations.length && monacoEditor.executeEdits(_editorCommandId, editOperations);\n  };\n\n  this.addJSXCommentCommand = function () {\n    var monacoEditor = monacoEditorManager.monacoEditor,\n        monaco = monacoEditorManager.monaco,\n        loc2Range = monacoEditorManager.loc2Range,\n        runEditorCommentLineAction = monacoEditorManager.runEditorCommentLineAction,\n        getCommentableStartingRange = monacoEditorManager.getCommentableStartingRange,\n        getCommentContainingStartingRange = monacoEditorManager.getCommentContainingStartingRange;\n\n    if (_editorCommandId) {\n      _isJSXCommentCommandActive = true;\n      return editorCommandOnDispose;\n    }\n\n    _editorCommandId = monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_SLASH, function () {\n      if (!_isJSXCommentCommandActive) {\n        runEditorCommentLineAction();\n        return;\n      }\n\n      parseJSXExpressionsPromise().then(function (jsxExpressions) {\n        var selection = monacoEditor.getSelection();\n        var commentContext = getJSXContext(jsxExpressions, getCommentableStartingRange(selection), getCommentContainingStartingRange(selection), loc2Range);\n\n        _this2.runJsxCommentAction(selection, commentContext);\n      }).catch(function () {\n        runEditorCommentLineAction();\n      });\n    });\n    _isJSXCommentCommandActive = true;\n    monacoEditor.onDidDispose(editorCommandOnDispose);\n    return editorCommandOnDispose;\n  };\n};\n\nvar defaultOptions = {\n  parser: 'babel',\n  isHighlightGlyph: false,\n  iShowHover: false,\n  isUseSeparateElementStyles: false,\n  jsxCommenter: null,\n  monacoEditorManager: null,\n  decoratorMapper: null\n};\n\nvar makeGetAstPromise = function makeGetAstPromise(parse, monacoEditor) {\n  return function () {\n    return new Promise(function (resolve, reject) {\n      try {\n        return resolve(parse(monacoEditor.getValue()));\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n};\n\nvar makeParseJSXExpressionsPromise = function makeParseJSXExpressionsPromise(traverse, getAstPromise) {\n  var _collectJSXExpressions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : collectJSXExpressions;\n\n  return function () {\n    return new Promise(function (resolve, reject) {\n      getAstPromise().then(function (ast) {\n        try {\n          return resolve(_collectJSXExpressions(ast, traverse));\n        } catch (e) {\n          return reject(e);\n        }\n      }).catch(function (e) {\n        return reject(e);\n      });\n    });\n  };\n};\n\nvar makeJSXCommenterBundle = function makeJSXCommenterBundle(monaco, parse, traverse, monacoEditor) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var parserType = options.parserType,\n      jsxCommenter = options.jsxCommenter,\n      monacoEditorManager = options.monacoEditorManager;\n  var range2Loc = configureRange2Loc(parserType);\n  var loc2Range = configureLoc2Range(monaco, parserType);\n  var getAstPromise = makeGetAstPromise(parse, monacoEditor);\n  var parseJSXExpressionsPromise = makeParseJSXExpressionsPromise(traverse, getAstPromise);\n\n  var _monacoEditorManager = monacoEditorManager || new MonacoEditorManager(monacoEditor, monaco, loc2Range);\n\n  var _jsxCommenter = jsxCommenter || new Commenter(_monacoEditorManager, parseJSXExpressionsPromise);\n\n  return [_jsxCommenter, _monacoEditorManager, parseJSXExpressionsPromise, getAstPromise, loc2Range, range2Loc];\n};\n\nvar makeBabelParse = function makeBabelParse(parse) {\n  return function (code) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return parse(code, _objectSpread(_objectSpread({}, options), {}, {\n      sourceType: \"module\",\n      plugins: [\"jsx\"],\n      errorRecovery: true\n    }));\n  };\n};\n\nvar MonacoJSXHighlighter = function MonacoJSXHighlighter(monaco, parse, traverse, monacoEditor) {\n  var _this3 = this;\n\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  _classCallCheck(this, MonacoJSXHighlighter);\n\n  this.options = _objectSpread(_objectSpread({}, defaultOptions), options);\n  var _this$options = this.options,\n      jsxCommenter = _this$options.jsxCommenter,\n      monacoEditorManager = _this$options.monacoEditorManager,\n      decoratorMapper = _this$options.decoratorMapper;\n  this.babelParse = makeBabelParse(parse);\n\n  var _makeJSXCommenterBund = makeJSXCommenterBundle(monaco, this.babelParse, traverse, monacoEditor, this.options),\n      _makeJSXCommenterBund2 = _slicedToArray(_makeJSXCommenterBund, 6),\n      _jsxCommenter = _makeJSXCommenterBund2[0],\n      _monacoEditorManager = _makeJSXCommenterBund2[1],\n      parseJSXExpressionsPromise = _makeJSXCommenterBund2[2],\n      getAstPromise = _makeJSXCommenterBund2[3],\n      loc2Range = _makeJSXCommenterBund2[4],\n      range2Loc = _makeJSXCommenterBund2[5];\n\n  this.jsxCommenter = jsxCommenter || _jsxCommenter;\n  this.monacoEditorManager = monacoEditorManager || _monacoEditorManager;\n  this.parseJSXExpressionsPromise = parseJSXExpressionsPromise;\n  this.getAstPromise = getAstPromise;\n  this.loc2Range = loc2Range;\n  this.range2Loc = range2Loc;\n  this.addJSXCommentCommand = this.jsxCommenter.addJSXCommentCommand;\n  this.decoratorMapper = decoratorMapper || new DecoratorMapper(monacoEditor, this.loc2Range);\n\n  this.decoratorMapperReset = function () {\n    decoratorMapper.reset();\n  };\n\n  this.highlight = function (ast) {\n    var _collectJSXExpressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : collectJSXExpressions;\n\n    return new Promise(function (resolve, reject) {\n      var decoratorMapper = _this3.decoratorMapper,\n          options = _this3.options;\n      var result = {\n        decoratorMapper: decoratorMapper,\n        options: options,\n        ast: ast,\n        jsxExpressions: []\n      };\n\n      if (!ast) {\n        return resolve(result);\n      }\n\n      try {\n        var jsxExpressions = _collectJSXExpressions(ast, traverse);\n\n        decoratorMapper.deltaJSXDecorations(jsxExpressions, options);\n        result.jsxExpressions = jsxExpressions;\n        return resolve(result);\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n\n  this.highlightCode = function () {\n    var afterHighlight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (ast) {\n      return ast;\n    };\n    var onHighlightError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (error) {\n      return error;\n    };\n    var getAstPromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this3.getAstPromise;\n    var onGetAstError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (error) {\n      return error;\n    };\n    return getAstPromise().then(function (ast) {\n      _this3.highlight(ast).then(afterHighlight).catch(onHighlightError);\n    }).catch(onGetAstError);\n  };\n\n  var _isHighlightBoundToModelContentChanges = false;\n\n  this.isHighlightBoundToModelContentChanges = function () {\n    return _isHighlightBoundToModelContentChanges;\n  };\n\n  this.highlightOnDidChangeModelContent = function () {\n    var debounceTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    var afterHighlight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ast) {\n      return ast;\n    };\n    var onHighlightError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (error) {\n      return error;\n    };\n    var getAstPromise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _this3.getAstPromise;\n    var onParseAstError = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (error) {\n      return error;\n    };\n\n    var highlightCallback = function highlightCallback() {\n      return _this3.highlightCode(afterHighlight, onHighlightError, getAstPromise, onParseAstError);\n    };\n\n    highlightCallback();\n    var tid = null;\n    var highlighterDisposer = {\n      onDidChangeModelContentDisposer: monacoEditor.onDidChangeModelContent(function () {\n        clearTimeout(tid);\n        tid = setTimeout(highlightCallback, debounceTime);\n      }),\n      onDidChangeModelDisposer: monacoEditor.onDidChangeModel(function () {\n        highlightCallback();\n      })\n    };\n\n    highlighterDisposer.dispose = function () {\n      highlighterDisposer.onDidChangeModelContentDisposer.dispose();\n      highlighterDisposer.onDidChangeModelDisposer.dispose();\n    };\n\n    _isHighlightBoundToModelContentChanges = true;\n\n    var onDispose = function onDispose() {\n      _this3.decoratorMapper.reset();\n\n      if (!_isHighlightBoundToModelContentChanges) {\n        return;\n      }\n\n      _isHighlightBoundToModelContentChanges = false;\n      highlighterDisposer && highlighterDisposer.dispose();\n      highlighterDisposer = null;\n    };\n\n    monacoEditor.onDidDispose(function () {\n      _this3.decoratorMapper.reset();\n\n      highlighterDisposer = null;\n      _isHighlightBoundToModelContentChanges = false;\n    });\n    return onDispose;\n  };\n\n  this.highLightOnDidChangeModelContent = this.highlightOnDidChangeModelContent;\n};\n\nexport { COMMENT_ACTION_ID, HIGHLIGHT_MODE, HIGHLIGHT_TYPE, JSXCommentContexts, JSXTypes, MonacoEditorManager, cloneLoc, collectJSXExpressions, configureLoc2Range, configureRange2Loc, MonacoJSXHighlighter as default, extractJSXClosingElement, extractJSXExpressionEdges, extractJSXOpeningElement, getCuratedLoc, getJSXContext, getLoc, isJSXIdentifier, isParentJSXAttribute, makeBabelParse, makeGetAstPromise, makeJSXCommenterBundle, makeParseJSXExpressionsPromise, prepareOptions };","map":{"version":3,"sources":["../../node_modules/style-inject/dist/style-inject.es.js","../../src/utils/babel.js","../../src/utils/monaco.js","../../src/core/DecoratorMapper.js","../../src/core/Commenter.js","../../src/core/MonacoJSXHighlighter.js"],"names":["ref","insertAt","head","document","style","collectJSXExpressions","traverseOptions","jsxExpressions","enter","path","traverse","isJSXIdentifier","isParentJSXAttribute","getLoc","cloneLoc","loc","start","end","getCuratedLoc","extractJSXOpeningElement","openingElement","elementName","startLoc","endLoc","extractJSXClosingElement","closingElement","extractJSXExpressionEdges","innerNode","innerLocKey","innerLoc","startEdgeLoc","endEdgeLoc","COMMENT_ACTION_ID","configureLoc2Range","parserType","startLineOffset","startColumnOffset","endLineOffset","endColumnOffset","monaco","configureRange2Loc","line","column","rangeOrPosition","constructor","loc2Range","lineNumber","range","startColumn","commentableRange","containingRange","model","startLineNumber","jsCommentRange","prepareOptions","jsxTypeOptions","highlighterOptions","hoverMessage","type","HIGHLIGHT_TYPE","ELEMENT","ALL","IDENTIFIER","EDGE","STYLE","HIGHLIGHT_MODE","result","JSXTypes","curatedLoc","options","JSXIdentifier","highlightScope","inlineClassName","JSXOpeningFragment","JSXClosingFragment","JSXText","JSXExpressionContainer","JSXSpreadChild","JSXSpreadAttribute","JSXElement","glyphMarginClassName","glyphMarginHoverMessage","JSXBracket","openingElementOptions","closingElementOptions","JSXOpeningElement","JSXClosingElement","JSXAttribute","_JSXTypes","decorators","jsxDecoratorIds","addDecorator","deltaDecorations","monacoEditor","entry","JSXCommentContexts","JS","JSX","minRange","minCommentableRange","commentablePath","p","jsxRange","_editorCommandId","_isJSXCommentCommandActive","editorCommandOnDispose","getSelectionFirstLineText","jsCommentText","runEditorCommentLineAction","isUnCommentAction","commentsData","i","selection","commentRange","commentText","commentContext","editOperations","commentsDataIndex","identifier","major","minor","text","forceMoveMarkers","getCommentContainingStartingRange","parseJSXExpressionsPromise","getJSXContext","getCommentableStartingRange","defaultOptions","parser","isHighlightGlyph","iShowHover","isUseSeparateElementStyles","jsxCommenter","monacoEditorManager","decoratorMapper","makeGetAstPromise","resolve","parse","reject","makeParseJSXExpressionsPromise","_collectJSXExpressions","getAstPromise","ast","e","makeJSXCommenterBundle","range2Loc","_monacoEditorManager","_jsxCommenter","makeBabelParse","sourceType","plugins","errorRecovery","afterHighlight","onHighlightError","error","onGetAstError","_isHighlightBoundToModelContentChanges","debounceTime","onParseAstError","highlightCallback","tid","highlighterDisposer","onDidChangeModelContentDisposer","clearTimeout","setTimeout","onDidChangeModelDisposer","onDispose"],"mappings":"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","sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// gets JSX expressions within a Babel's AST\nexport const collectJSXExpressions = (ast, traverse, traverseOptions = {}) => {\n   const jsxExpressions = [];\n   \n   const enter = (path) => {\n      if (path.type.toUpperCase().includes(\"JSX\")) {\n         jsxExpressions.push(path);\n      }\n   }\n   \n   traverse(ast, {...traverseOptions, enter});\n   \n   return jsxExpressions;\n}\n\nexport const isJSXIdentifier = (path) => {\n   return (path && (\n         path.key === 'object' ||\n         path.key === 'property' ||\n         path.key === 'name' ||\n         path.key === 'namespace'\n      )\n   );\n}\n\nexport const isParentJSXAttribute = (path) => {\n   return (\n      path &&\n      path.parentPath &&\n      path.parentPath.isJSXAttribute()\n   );\n};\n\nexport const getLoc = (path) => {\n   return (path && path.node && path.node.loc);\n};\n\nexport const cloneLoc = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return null;\n   }\n   \n   return {\n      start: {...loc.start},\n      end: {...loc.end}\n   };\n   \n};\n\n// prevents spilling highlighting on objects props\nexport const getCuratedLoc = (path) => {\n   const loc = cloneLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   if (path.key === 'object' && path.container) {\n      loc.end = {...path.container.property.loc.start};\n   }\n   \n   return loc;\n   \n};\n\nexport const extractJSXOpeningElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const openingElement = path.node.openingElement;\n   \n   if (!openingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = openingElement.name.name;\n   \n   const startLoc = {\n      start: {...openingElement.loc.start},\n      end: {...openingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...openingElement.loc.end},\n      end: {...openingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   if (openingElement.selfClosing) {\n      endLoc.start.column--;\n   }\n   \n   return [openingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXClosingElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const closingElement = path.node.closingElement;\n   \n   if (!closingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = closingElement.name && closingElement.name.name;\n   \n   const startLoc = {\n      start: {...closingElement.loc.start},\n      end: {...closingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...closingElement.loc.end},\n      end: {...closingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   return [closingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXExpressionEdges = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   let innerNode = null;\n   let innerLocKey = path.isJSXSpreadChild() ? 'expression'\n      : path.isJSXSpreadAttribute() ? 'argument'\n         : null;\n   \n   let innerLoc = null;\n   \n   if (innerLocKey) {\n      innerNode = path.node[innerLocKey];\n      \n      innerLoc = {\n         start: {...innerNode.loc.start},\n         end: {...innerNode.loc.end}\n      };\n      \n      if (innerNode.extra && innerNode.extra.parenthesized) {\n         innerLoc.start.column--;\n         innerLoc.end.column++;\n      }\n   } else {\n      innerLoc = {start: {...loc.start}, end: {...loc.end}};\n      innerLoc.start.column++;\n      innerLoc.end.column--;\n   }\n   \n   const startEdgeLoc = {start: {...loc.start}, end: {...innerLoc.start}};\n   \n   const endEdgeLoc = {start: {...innerLoc.end}, end: {...loc.end}};\n   return [innerNode, innerLocKey, startEdgeLoc, endEdgeLoc];\n};\n","export const COMMENT_ACTION_ID = \"editor.action.commentLine\";\n\n// adapts location objects (e.g. Babel uses internally Acorn) to Monaco Ranges\nexport const configureLoc2Range = (\n   monaco, parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            loc,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            if (!loc || !loc.start) {\n               return new monaco.Range(\n                  1,\n                  1,\n                  1,\n                  1\n               );\n            }\n            return new monaco.Range(\n               startLineOffset + loc.start.line,\n               startColumnOffset + loc.start.column + 1,\n               endLineOffset + loc.end ?\n                  loc.end.line\n                  : loc.start.line,\n               endColumnOffset + loc.end ?\n                  loc.end.column + 1\n                  : loc.start.column + 1,\n            );\n         };\n   }\n};\n\nexport const configureRange2Loc = (\n   parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            rangeOrPosition,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            const loc = {\n               start: {line: 0, column: 0},\n               end: {line: 0, column: 0}\n            };\n            \n            if (!rangeOrPosition) {\n               return loc;\n            }\n            \n            // position\n            if (rangeOrPosition.lineNumber) {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.lineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.column - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.lineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.column - 1;\n            } else {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.startLineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.startColumn - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.endLineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.endColumn - 1;\n            }\n            \n            return loc;\n         };\n   }\n};\n\nexport class MonacoEditorManager {\n   constructor(monacoEditor, monaco, loc2Range) {\n      this.monacoEditor = monacoEditor;\n      this.monaco = monaco;\n      this.loc2Range = loc2Range || configureRange2Loc(monaco);\n      \n      // default editor comment action\n      this.runEditorCommentLineAction = () => {\n         return this.monacoEditor\n            .getAction(COMMENT_ACTION_ID)\n            .run();\n      };\n      \n      // preserves indentation when commenting code\n      this.getLineIndentationColumn = (lineNumber) => {\n         return this.monacoEditor\n            .getModel()\n            .getLineFirstNonWhitespaceColumn(\n               lineNumber\n            );\n      };\n      \n      this.getCommentableStartingRange = (range) => {\n         const startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         // creates an anchor to check for comments\n         const commentableRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return commentableRange;\n      };\n      \n      this.getCommentContainingStartingRange = (range) => {\n         // preserves indentation when commenting code\n         let startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         startColumn = startColumn ? startColumn - 1 : 0;\n         const containingRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return containingRange;\n      };\n      \n      this.getSelectionFirstLineText = () => {\n         const model = this.monacoEditor.getModel();\n         const {startLineNumber} = this.monacoEditor.getSelection();\n         \n         const jsCommentRange = new this.monaco.Range(\n            startLineNumber,\n            this.getLineIndentationColumn(\n               startLineNumber\n            ),\n            startLineNumber,\n            model.getLineMaxColumn(startLineNumber),\n         );\n         return model.getValueInRange(jsCommentRange);\n      };\n   }\n}\n","import {\n   extractJSXOpeningElement,\n   extractJSXClosingElement,\n   getLoc,\n   getCuratedLoc,\n   isJSXIdentifier,\n   isParentJSXAttribute,\n   extractJSXExpressionEdges\n} from \"../utils/babel\";\n\nexport const prepareOptions =(\n   path,\n   jsxTypeOptions = {},\n   highlighterOptions = {}\n) =>{\n   return highlighterOptions.iShowHover ?\n      {...jsxTypeOptions, ...{hoverMessage: `(${path.type})`}}\n      : jsxTypeOptions;\n};\n\nexport const HIGHLIGHT_TYPE = {\n   ELEMENT: 'ELEMENT', // jsx elements\n   ALL: 'ALL', // the whole node's location, e.g. identifier names\n   IDENTIFIER: 'IDENTIFIER', // JSX identifiers\n   EDGE: 'EDGE', // only the  starting and ending characters in node's\n   // location e.g. spread child or attribute, container expressions\n   STYLE: 'STYLE', // for styling only, not used by node locations\n};\n\n\nexport const HIGHLIGHT_MODE = {\n   /**\n    *  ALL functions follow this signature:\n    *  @param {Babel Path} - the path to process.\n    *  @param {Object} jsxTypeOptions - the Monaco Decorator options to be used.\n    *  @param {Object} highlighterOptions - this library configuration for\n    *  highlighting.\n    *  @returns {Array} a collection JSX entries, each entry is an array too:\n    *  0: location object matching Babel's Location structure.\n    *  1: JSXTypes' Monaco options to create a highlighting  decorator.\n    *  Note: Purposely array entries to prevent using them directly with\n    Monaco without properly adapting Babel locations to Monaco Ranges.\n    **/\n   [HIGHLIGHT_TYPE.ELEMENT]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const [\n         openingElement, elementName, startLoc, endLoc\n      ] = extractJSXOpeningElement(path);\n      \n      const result = [];\n      \n      if (openingElement) {\n         result.push([\n            startLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         \n         result.push([\n            endLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const [\n         closingElement, , closingElementStartLoc, closingElementEndLoc\n      ] = extractJSXClosingElement(path);\n      \n      if (closingElement) {\n         result.push([\n            closingElementStartLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         result.push([\n            closingElementEndLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const loc = getLoc(path);\n      highlighterOptions.isHighlightGlyph && result.push([\n         loc,\n         JSXTypes.JSXElement.options(elementName)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.ALL]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const curatedLoc = getCuratedLoc(path);\n      const result = [];\n      curatedLoc && result.push([\n         curatedLoc,\n         prepareOptions(path, jsxTypeOptions, highlighterOptions)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.IDENTIFIER]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      if (!isJSXIdentifier(path)) {\n         return [];\n      }\n      \n      return HIGHLIGHT_MODE[HIGHLIGHT_TYPE.ALL](\n         path,\n         isParentJSXAttribute(path) ?\n            JSXTypes.JSXAttribute.options : jsxTypeOptions,\n         highlighterOptions,\n      );\n   },\n   [HIGHLIGHT_TYPE.EDGE]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const options = prepareOptions(path, jsxTypeOptions, highlighterOptions);\n      \n      const [\n         , , startEdgeLoc, endEdgeLoc\n      ] = extractJSXExpressionEdges(path);\n      \n      const result = [];\n      \n      result.push([\n         startEdgeLoc,\n         options\n      ]);\n      result.push([\n         endEdgeLoc,\n         options\n      ]);\n      \n      return result;\n      \n   },\n   [HIGHLIGHT_TYPE.STYLE]: () => [], // noop\n};\n\nexport const JSXTypes = {\n   JSXIdentifier: {\n      highlightScope: HIGHLIGHT_TYPE.IDENTIFIER,\n      options: {\n         inlineClassName: 'JSXElement.JSXIdentifier',\n      },\n   },\n   JSXOpeningFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXOpeningFragment.JSXBracket',\n      },\n   },\n   JSXClosingFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXClosingFragment.JSXBracket',\n      },\n   },\n   JSXText: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXElement.JSXText',\n      },\n   },\n   JSXExpressionContainer: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXExpressionContainer.JSXBracket',\n      },\n   },\n   JSXSpreadChild: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadChild.JSXBracket',\n      },\n   },\n   JSXSpreadAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadAttribute.JSXBracket',\n      },\n   },\n   JSXElement: {\n      highlightScope: HIGHLIGHT_TYPE.ELEMENT, //HIGHLIGHT_TYPE.STYLE,\n      options: (elementName) => (\n         {\n            glyphMarginClassName: 'JSXElement.JSXGlyph',\n            glyphMarginHoverMessage:\n               `JSX Element${elementName ? ': ' + elementName : ''}`\n         }\n      ),\n   },\n   JSXBracket: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXElement.JSXBracket',\n      },\n      openingElementOptions: {\n         inlineClassName: 'JSXOpeningElement.JSXBracket',\n      },\n      closingElementOptions: {\n         inlineClassName: 'JSXClosingElement.JSXBracket',\n      },\n   },\n   JSXOpeningElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXOpeningElement.JSXIdentifier',\n      },\n   },\n   JSXClosingElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXClosingElement.JSXIdentifier',\n      },\n   },\n   JSXAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXAttribute.JSXIdentifier',\n      },\n   },\n};\n\nclass DecoratorMapper {\n   constructor(monacoEditor, loc2Range, _JSXTypes = JSXTypes) {\n      let decorators = [];\n      let jsxDecoratorIds = [];\n      \n      const addDecorator = ([loc, options]) => {\n         return decorators.push({\n            range: loc2Range(loc),\n            options\n         });\n      }\n      \n      const deltaDecorations = () => {\n         jsxDecoratorIds =\n            monacoEditor.deltaDecorations(\n               jsxDecoratorIds || [],\n               decorators\n            );\n         decorators = [];\n         return jsxDecoratorIds;\n      }\n      \n      this.deltaJSXDecorations = (jsxExpressions, options) => {\n         for (const jsxType in _JSXTypes) {\n            jsxExpressions.filter(path => path.type === jsxType)\n               .forEach(path =>\n                  HIGHLIGHT_MODE[_JSXTypes[jsxType].highlightScope](\n                     path,\n                     _JSXTypes[jsxType].options,\n                     options,\n                  ).forEach(entry => addDecorator(entry))\n               );\n         }\n         \n         return deltaDecorations();\n      }\n      \n      this.reset = () => {\n         decorators = [];\n         deltaDecorations();\n      }\n      \n      this.reset();\n   }\n}\n\nexport default DecoratorMapper;\n","export const JSXCommentContexts = {\n   JS: 'JS',\n   JSX: 'JSX'\n}\n\nexport function getJSXContext(\n   jsxExpressions,\n   commentableRange,\n   commentContainingRange,\n   loc2Range\n) {\n   if (!(jsxExpressions &&\n      commentableRange &&\n      commentContainingRange &&\n      loc2Range)) {\n      return JSXCommentContexts.JS;\n   }\n   \n   \n   let minRange = null;\n   let minCommentableRange = null;\n   let path = null;\n   let commentablePath = null;\n   \n   jsxExpressions.forEach(p => {\n      const jsxRange = loc2Range(p.node.loc);\n      if ((p.key === 'name' || p.key === 'property') &&\n         p.isJSXIdentifier() &&\n         jsxRange.intersectRanges(commentableRange)) {\n         if (\n            !minCommentableRange ||\n            minCommentableRange.containsRange(jsxRange)\n         ) {\n            minCommentableRange = jsxRange;\n            commentablePath = p;\n         }\n      }\n      if (jsxRange.intersectRanges(commentContainingRange)) {\n         if (!minRange || minRange.containsRange(jsxRange)) {\n            minRange = jsxRange;\n            path = p;\n         }\n      }\n   });\n   \n   if (!path || path.isJSXExpressionContainer() || commentablePath) {\n      return JSXCommentContexts.JS;\n   } else {\n      return JSXCommentContexts.JSX;\n   }\n}\n\nclass Commenter {\n   constructor(\n      monacoEditorManager,\n      parseJSXExpressionsPromise\n   ) {\n      \n      let _editorCommandId = null;\n      \n      this.getEditorCommandId = () => {\n         return _editorCommandId;\n      }\n      \n      let _isJSXCommentCommandActive = false;\n      \n      this.isJSXCommentCommandActive = () => {\n         return _isJSXCommentCommandActive;\n      }\n      \n      const editorCommandOnDispose = () => {\n         _isJSXCommentCommandActive = false;\n      };\n      \n      this.runJsxCommentAction = (selection, commentContext) => {\n         const {\n            monacoEditor, monaco, runEditorCommentLineAction,\n            getSelectionFirstLineText,\n         } = monacoEditorManager;\n         \n         const jsCommentText = getSelectionFirstLineText();\n         \n         if (jsCommentText.match(/^\\s*\\/[/*]/)) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         const model = monacoEditor.getModel();\n         \n         let isUnCommentAction = true;\n         const commentsData = [];\n         \n         for (\n            let i = selection.startLineNumber; i <= selection.endLineNumber; i++\n         ) {\n            const commentRange = new monaco.Range(\n               i,\n               model.getLineFirstNonWhitespaceColumn(i),\n               i,\n               model.getLineMaxColumn(i),\n            );\n            \n            const commentText = model.getValueInRange(commentRange);\n            \n            commentsData.push({\n               commentRange,\n               commentText\n            });\n            \n            isUnCommentAction = isUnCommentAction &&\n               !!commentText.match(/{\\/\\*/);\n         }\n         \n         if (commentContext !== JSXCommentContexts.JSX\n            && !isUnCommentAction) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         let editOperations = [];\n         let commentsDataIndex = 0;\n         \n         for (let i = selection.startLineNumber;\n              i <= selection.endLineNumber;\n              i++) {\n            let {\n               commentText,\n               commentRange,\n            } = commentsData[commentsDataIndex++];\n            \n            if (isUnCommentAction) {\n               commentText = commentText.replace(/{\\/\\*/, '');\n               commentText = commentText.replace(/\\*\\/}/, '');\n            } else {\n               commentText = `{/*${commentText}*/}`;\n            }\n            \n            editOperations.push({\n               identifier: {major: 1, minor: 1},\n               range: commentRange,\n               text: commentText,\n               forceMoveMarkers: true,\n            });\n         }\n         editOperations.length &&\n         monacoEditor.executeEdits(_editorCommandId, editOperations);\n      }\n      \n      this.addJSXCommentCommand = () => {\n         const {\n            monacoEditor, monaco, loc2Range, runEditorCommentLineAction,\n            getCommentableStartingRange, getCommentContainingStartingRange\n         } = monacoEditorManager;\n         \n         if (_editorCommandId) {\n            _isJSXCommentCommandActive = true;\n            return editorCommandOnDispose;\n         }\n         \n         _editorCommandId = monacoEditor.addCommand(\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_SLASH,\n            () => {\n               if (!_isJSXCommentCommandActive) {\n                  runEditorCommentLineAction();\n                  return;\n               }\n               \n               parseJSXExpressionsPromise()\n                  .then(jsxExpressions => {\n                     const selection = monacoEditor.getSelection();\n                     const commentContext = getJSXContext(\n                        jsxExpressions,\n                        getCommentableStartingRange(selection),\n                        getCommentContainingStartingRange(selection),\n                        loc2Range\n                     );\n                     this.runJsxCommentAction(selection, commentContext);\n                  }).catch(()=>{\n                   runEditorCommentLineAction();\n               });\n            });\n         \n         _isJSXCommentCommandActive = true;\n         \n         monacoEditor.onDidDispose(editorCommandOnDispose);\n         \n         return editorCommandOnDispose;\n      }\n   }\n}\n\nexport default Commenter;\n","import {\n   configureLoc2Range,\n   configureRange2Loc,\n   MonacoEditorManager\n} from '../utils/monaco';\nimport {collectJSXExpressions} from '../utils/babel';\nimport DecoratorMapper from './DecoratorMapper';\nimport Commenter from './Commenter';\n\nconst defaultOptions = {\n   parser: 'babel',\n   isHighlightGlyph: false,\n   iShowHover: false,\n   isUseSeparateElementStyles: false,\n   jsxCommenter: null,\n   monacoEditorManager: null,\n   decoratorMapper: null,\n};\n\nexport const makeGetAstPromise = (parse, monacoEditor) => () => {\n   return new Promise(\n      (resolve, reject) => {\n         try {\n            return resolve(\n               parse(monacoEditor.getValue()) // ast\n            );\n         } catch (e) {\n            return reject(e);\n         }\n      }\n   );\n};\n\nexport const makeParseJSXExpressionsPromise = (\n   traverse, getAstPromise, _collectJSXExpressions = collectJSXExpressions\n) => () => {\n   return new Promise((resolve, reject) => {\n      getAstPromise()\n         .then(ast => {\n               try {\n                  return resolve(\n                     _collectJSXExpressions(ast, traverse)\n                  );\n               } catch (e) {\n                  return reject(e);\n               }\n            }\n         ).catch(e => reject(e));\n   });\n};\n\nexport const makeJSXCommenterBundle = (\n   monaco, parse, traverse, monacoEditor, options = {}\n) => {\n   const {parserType, jsxCommenter, monacoEditorManager} = options;\n   const range2Loc = configureRange2Loc(parserType);\n   const loc2Range = configureLoc2Range(monaco, parserType);\n   \n   const getAstPromise = makeGetAstPromise(parse, monacoEditor);\n   \n   const parseJSXExpressionsPromise = makeParseJSXExpressionsPromise(\n      traverse, getAstPromise\n   );\n   \n   const _monacoEditorManager = monacoEditorManager ||\n      new MonacoEditorManager(monacoEditor, monaco, loc2Range);\n   \n   const _jsxCommenter = jsxCommenter || new Commenter(\n      _monacoEditorManager, parseJSXExpressionsPromise\n   );\n   \n   return [\n      _jsxCommenter, _monacoEditorManager,\n      parseJSXExpressionsPromise, getAstPromise,\n      loc2Range, range2Loc\n   ];\n};\n\n// Minimal Babel setup for React JSX parsing:\nexport const makeBabelParse = (parse) => {\n   return (code, options = {}) => {\n      return parse(\n         code,\n         {\n            ...options,\n            sourceType: \"module\",\n            plugins: [\"jsx\"],\n            errorRecovery: true\n         });\n      \n   };\n};\n\nclass MonacoJSXHighlighter {\n   constructor(\n      monaco,\n      parse,\n      traverse,\n      monacoEditor,\n      options = {}\n   ) {\n      this.options = {...defaultOptions, ...options};\n      \n      const {jsxCommenter, monacoEditorManager, decoratorMapper} = this.options;\n      \n      this.babelParse = makeBabelParse(parse);\n      \n      const [\n         _jsxCommenter, _monacoEditorManager,\n         parseJSXExpressionsPromise, getAstPromise,\n         loc2Range, range2Loc\n      ] = makeJSXCommenterBundle(\n         monaco, this.babelParse, traverse, monacoEditor, this.options\n      );\n      \n      this.jsxCommenter = jsxCommenter || _jsxCommenter;\n      this.monacoEditorManager = monacoEditorManager || _monacoEditorManager;\n      this.parseJSXExpressionsPromise = parseJSXExpressionsPromise;\n      this.getAstPromise = getAstPromise;\n      this.loc2Range = loc2Range;\n      this.range2Loc = range2Loc;\n      \n      this.addJSXCommentCommand = this.jsxCommenter.addJSXCommentCommand;\n      \n      \n      this.decoratorMapper = decoratorMapper ||\n         new DecoratorMapper(monacoEditor, this.loc2Range);\n      this.decoratorMapperReset = () => {\n         decoratorMapper.reset()\n      };\n      \n      this.highlight = (\n         ast, _collectJSXExpressions = collectJSXExpressions\n      ) => {\n         return new Promise((resolve, reject) => {\n            const {decoratorMapper, options} = this;\n            const result = {\n               decoratorMapper,\n               options,\n               ast,\n               jsxExpressions: [],\n            };\n            \n            //ignore update if parsing was unsuccessful\n            if (!ast) {\n               return resolve(result);\n            }\n            \n            try {\n               const jsxExpressions = _collectJSXExpressions(ast, traverse);\n               \n               decoratorMapper.deltaJSXDecorations(\n                  jsxExpressions, options\n               );\n               \n               result.jsxExpressions = jsxExpressions;\n               \n               return resolve(result);\n            } catch (e) {\n               return reject(e);\n            }\n         });\n      };\n      \n      this.highlightCode = (\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onGetAstError = error => error,\n      ) => {\n         return (\n            getAstPromise()\n               .then(ast => {\n                  this.highlight(ast)\n                     .then(afterHighlight)\n                     .catch(onHighlightError)\n               })\n               .catch(onGetAstError)\n         );\n      };\n      \n      let _isHighlightBoundToModelContentChanges = false;\n      \n      this.isHighlightBoundToModelContentChanges =\n         () => _isHighlightBoundToModelContentChanges;\n      \n      this.highlightOnDidChangeModelContent = (\n         debounceTime = 100,\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onParseAstError = error => error,\n      ) => {\n         const highlightCallback = () => {\n            return this.highlightCode(\n               afterHighlight,\n               onHighlightError,\n               getAstPromise,\n               onParseAstError\n            );\n         };\n         \n         highlightCallback();\n         \n         let tid = null;\n         \n         let highlighterDisposer = {\n            onDidChangeModelContentDisposer:\n               monacoEditor.onDidChangeModelContent(\n                  () => {\n                     clearTimeout(tid);\n                     tid = setTimeout(\n                        highlightCallback,\n                        debounceTime\n                     );\n                  }),\n            onDidChangeModelDisposer: monacoEditor.onDidChangeModel(\n               () => {\n                  highlightCallback();\n               })\n         };\n         \n         highlighterDisposer.dispose = () => {\n            highlighterDisposer.onDidChangeModelContentDisposer.dispose();\n            highlighterDisposer.onDidChangeModelDisposer.dispose();\n         };\n         \n         _isHighlightBoundToModelContentChanges = true;\n         \n         const onDispose = () => {\n            this.decoratorMapper.reset();\n            if (\n               !_isHighlightBoundToModelContentChanges\n            ) {\n               return;\n            }\n            _isHighlightBoundToModelContentChanges = false;\n            highlighterDisposer && highlighterDisposer.dispose();\n            highlighterDisposer = null;\n            \n         }\n         \n         monacoEditor.onDidDispose(() => {\n            this.decoratorMapper.reset();\n            highlighterDisposer = null;\n            _isHighlightBoundToModelContentChanges = false;\n         });\n         \n         \n         return onDispose;\n      };\n      \n      // backwards compatible typo preserve to avoid breaking changes\n      this.highLightOnDidChangeModelContent =\n         this.highlightOnDidChangeModelContent;\n   }\n}\n\n// use .polyfilled dist when usign node < 10. // .babelrc.json:  \"node\": \"0\"\nexport default MonacoJSXHighlighter;\n"]},"metadata":{},"sourceType":"module"}