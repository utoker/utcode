{"ast":null,"code":"function styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".JSXElement.JSXIdentifier{color:#4169e1}.JSXElement.JSXBracket{color:#ff8c00}.JSXElement.JSXText{color:#b8860b}.JSXElement.JSXGlyph{background:cyan;opacity:.25}.JSXClosingFragment.JSXBracket,.JSXOpeningElement.JSXBracket,.JSXOpeningFragment.JSXBracket{color:#ff8c00;font-weight:700}.JSXOpeningElement.JSXIdentifier{color:#4169e1}.JSXClosingElement.JSXBracket{color:#ff8c00;font-weight:lighter}.JSXClosingElement.JSXIdentifier{color:#4169e1;font-weight:lighter}.JSXAttribute.JSXIdentifier{color:#4682b4}.JSXExpressionContainer.JSXBracket,.JSXSpreadAttribute.JSXBracket,.JSXSpreadChild.JSXBracket{color:#ff8c00}\";\nstyleInject(css_248z);\n\nconst collectJSXExpressions = (ast, traverse, traverseOptions = {}) => {\n  const jsxExpressions = [];\n\n  const enter = path => {\n    if (path.type.toUpperCase().includes(\"JSX\")) {\n      jsxExpressions.push(path);\n    }\n  };\n\n  traverse(ast, { ...traverseOptions,\n    enter\n  });\n  return jsxExpressions;\n};\n\nconst isJSXIdentifier = path => {\n  return path && (path.key === 'object' || path.key === 'property' || path.key === 'name' || path.key === 'namespace');\n};\n\nconst isParentJSXAttribute = path => {\n  return path && path.parentPath && path.parentPath.isJSXAttribute();\n};\n\nconst getLoc = path => {\n  return path && path.node && path.node.loc;\n};\n\nconst cloneLoc = path => {\n  const loc = getLoc(path);\n\n  if (!loc) {\n    return null;\n  }\n\n  return {\n    start: { ...loc.start\n    },\n    end: { ...loc.end\n    }\n  };\n};\n\nconst getCuratedLoc = path => {\n  const loc = cloneLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  if (path.key === 'object' && path.container) {\n    loc.end = { ...path.container.property.loc.start\n    };\n  }\n\n  return loc;\n};\n\nconst extractJSXOpeningElement = path => {\n  const loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  const openingElement = path.node.openingElement;\n\n  if (!openingElement) {\n    return [null, null, null, null];\n  }\n\n  const elementName = openingElement.name.name;\n  const startLoc = {\n    start: { ...openingElement.loc.start\n    },\n    end: { ...openingElement.name.loc.start\n    }\n  };\n  const endLoc = {\n    start: { ...openingElement.loc.end\n    },\n    end: { ...openingElement.loc.end\n    }\n  };\n  endLoc.start.column--;\n\n  if (openingElement.selfClosing) {\n    endLoc.start.column--;\n  }\n\n  return [openingElement, elementName, startLoc, endLoc];\n};\n\nconst extractJSXClosingElement = path => {\n  const loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  const closingElement = path.node.closingElement;\n\n  if (!closingElement) {\n    return [null, null, null, null];\n  }\n\n  const elementName = closingElement.name && closingElement.name.name;\n  const startLoc = {\n    start: { ...closingElement.loc.start\n    },\n    end: { ...closingElement.name.loc.start\n    }\n  };\n  const endLoc = {\n    start: { ...closingElement.loc.end\n    },\n    end: { ...closingElement.loc.end\n    }\n  };\n  endLoc.start.column--;\n  return [closingElement, elementName, startLoc, endLoc];\n};\n\nconst extractJSXExpressionEdges = path => {\n  const loc = getLoc(path);\n\n  if (!loc) {\n    return [null, null, null, null];\n  }\n\n  let innerNode = null;\n  let innerLocKey = path.isJSXSpreadChild() ? 'expression' : path.isJSXSpreadAttribute() ? 'argument' : null;\n  let innerLoc = null;\n\n  if (innerLocKey) {\n    innerNode = path.node[innerLocKey];\n    innerLoc = {\n      start: { ...innerNode.loc.start\n      },\n      end: { ...innerNode.loc.end\n      }\n    };\n\n    if (innerNode.extra && innerNode.extra.parenthesized) {\n      innerLoc.start.column--;\n      innerLoc.end.column++;\n    }\n  } else {\n    innerLoc = {\n      start: { ...loc.start\n      },\n      end: { ...loc.end\n      }\n    };\n    innerLoc.start.column++;\n    innerLoc.end.column--;\n  }\n\n  const startEdgeLoc = {\n    start: { ...loc.start\n    },\n    end: { ...innerLoc.start\n    }\n  };\n  const endEdgeLoc = {\n    start: { ...innerLoc.end\n    },\n    end: { ...loc.end\n    }\n  };\n  return [innerNode, innerLocKey, startEdgeLoc, endEdgeLoc];\n};\n\nconst COMMENT_ACTION_ID = \"editor.action.commentLine\";\n\nconst configureLoc2Range = (monaco, parserType = 'babel') => {\n  switch (parserType) {\n    case 'babel':\n    default:\n      return (loc, startLineOffset = 0, startColumnOffset = 0, endLineOffset = 0, endColumnOffset = 0) => {\n        if (!loc || !loc.start) {\n          return new monaco.Range(1, 1, 1, 1);\n        }\n\n        return new monaco.Range(startLineOffset + loc.start.line, startColumnOffset + loc.start.column + 1, endLineOffset + loc.end ? loc.end.line : loc.start.line, endColumnOffset + loc.end ? loc.end.column + 1 : loc.start.column + 1);\n      };\n  }\n};\n\nconst configureRange2Loc = (parserType = 'babel') => {\n  switch (parserType) {\n    case 'babel':\n    default:\n      return (rangeOrPosition, startLineOffset = 0, startColumnOffset = 0, endLineOffset = 0, endColumnOffset = 0) => {\n        const loc = {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        };\n\n        if (!rangeOrPosition) {\n          return loc;\n        }\n\n        if (rangeOrPosition.lineNumber) {\n          loc.start.line = startLineOffset + rangeOrPosition.lineNumber;\n          loc.start.column = startColumnOffset + rangeOrPosition.column - 1;\n          loc.end.line = endLineOffset + rangeOrPosition.lineNumber;\n          loc.end.column = endColumnOffset + rangeOrPosition.column - 1;\n        } else {\n          loc.start.line = startLineOffset + rangeOrPosition.startLineNumber;\n          loc.start.column = startColumnOffset + rangeOrPosition.startColumn - 1;\n          loc.end.line = endLineOffset + rangeOrPosition.endLineNumber;\n          loc.end.column = endColumnOffset + rangeOrPosition.endColumn - 1;\n        }\n\n        return loc;\n      };\n  }\n};\n\nclass MonacoEditorManager {\n  constructor(monacoEditor, monaco, loc2Range) {\n    this.monacoEditor = monacoEditor;\n    this.monaco = monaco;\n    this.loc2Range = loc2Range || configureRange2Loc(monaco);\n\n    this.runEditorCommentLineAction = () => {\n      return this.monacoEditor.getAction(COMMENT_ACTION_ID).run();\n    };\n\n    this.getLineIndentationColumn = lineNumber => {\n      return this.monacoEditor.getModel().getLineFirstNonWhitespaceColumn(lineNumber);\n    };\n\n    this.getCommentableStartingRange = range => {\n      const startColumn = this.getLineIndentationColumn(range.startLineNumber);\n      const commentableRange = new this.monaco.Range(range.startLineNumber, startColumn, range.startLineNumber, startColumn);\n      return commentableRange;\n    };\n\n    this.getCommentContainingStartingRange = range => {\n      let startColumn = this.getLineIndentationColumn(range.startLineNumber);\n      startColumn = startColumn ? startColumn - 1 : 0;\n      const containingRange = new this.monaco.Range(range.startLineNumber, startColumn, range.startLineNumber, startColumn);\n      return containingRange;\n    };\n\n    this.getSelectionFirstLineText = () => {\n      const model = this.monacoEditor.getModel();\n      const {\n        startLineNumber\n      } = this.monacoEditor.getSelection();\n      const jsCommentRange = new this.monaco.Range(startLineNumber, this.getLineIndentationColumn(startLineNumber), startLineNumber, model.getLineMaxColumn(startLineNumber));\n      return model.getValueInRange(jsCommentRange);\n    };\n  }\n\n}\n\nconst prepareOptions = (path, jsxTypeOptions = {}, highlighterOptions = {}) => {\n  return highlighterOptions.iShowHover ? { ...jsxTypeOptions,\n    ...{\n      hoverMessage: `(${path.type})`\n    }\n  } : jsxTypeOptions;\n};\n\nconst HIGHLIGHT_TYPE = {\n  ELEMENT: 'ELEMENT',\n  ALL: 'ALL',\n  IDENTIFIER: 'IDENTIFIER',\n  EDGE: 'EDGE',\n  STYLE: 'STYLE'\n};\nconst HIGHLIGHT_MODE = {\n  [HIGHLIGHT_TYPE.ELEMENT]: (path, jsxTypeOptions, highlighterOptions) => {\n    const [openingElement, elementName, startLoc, endLoc] = extractJSXOpeningElement(path);\n    const result = [];\n\n    if (openingElement) {\n      result.push([startLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.openingElementOptions : JSXTypes.JSXBracket.options]);\n      result.push([endLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.openingElementOptions : JSXTypes.JSXBracket.options]);\n    }\n\n    const [closingElement,, closingElementStartLoc, closingElementEndLoc] = extractJSXClosingElement(path);\n\n    if (closingElement) {\n      result.push([closingElementStartLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.closingElementOptions : JSXTypes.JSXBracket.options]);\n      result.push([closingElementEndLoc, highlighterOptions.isUseSeparateElementStyles ? JSXTypes.JSXBracket.closingElementOptions : JSXTypes.JSXBracket.options]);\n    }\n\n    const loc = getLoc(path);\n    highlighterOptions.isHighlightGlyph && result.push([loc, JSXTypes.JSXElement.options(elementName)]);\n    return result;\n  },\n  [HIGHLIGHT_TYPE.ALL]: (path, jsxTypeOptions, highlighterOptions) => {\n    const curatedLoc = getCuratedLoc(path);\n    const result = [];\n    curatedLoc && result.push([curatedLoc, prepareOptions(path, jsxTypeOptions, highlighterOptions)]);\n    return result;\n  },\n  [HIGHLIGHT_TYPE.IDENTIFIER]: (path, jsxTypeOptions, highlighterOptions) => {\n    if (!isJSXIdentifier(path)) {\n      return [];\n    }\n\n    return HIGHLIGHT_MODE[HIGHLIGHT_TYPE.ALL](path, isParentJSXAttribute(path) ? JSXTypes.JSXAttribute.options : jsxTypeOptions, highlighterOptions);\n  },\n  [HIGHLIGHT_TYPE.EDGE]: (path, jsxTypeOptions, highlighterOptions) => {\n    const options = prepareOptions(path, jsxTypeOptions, highlighterOptions);\n    const [,, startEdgeLoc, endEdgeLoc] = extractJSXExpressionEdges(path);\n    const result = [];\n    result.push([startEdgeLoc, options]);\n    result.push([endEdgeLoc, options]);\n    return result;\n  },\n  [HIGHLIGHT_TYPE.STYLE]: () => []\n};\nconst JSXTypes = {\n  JSXIdentifier: {\n    highlightScope: HIGHLIGHT_TYPE.IDENTIFIER,\n    options: {\n      inlineClassName: 'JSXElement.JSXIdentifier'\n    }\n  },\n  JSXOpeningFragment: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXOpeningFragment.JSXBracket'\n    }\n  },\n  JSXClosingFragment: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXClosingFragment.JSXBracket'\n    }\n  },\n  JSXText: {\n    highlightScope: HIGHLIGHT_TYPE.ALL,\n    options: {\n      inlineClassName: 'JSXElement.JSXText'\n    }\n  },\n  JSXExpressionContainer: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXExpressionContainer.JSXBracket'\n    }\n  },\n  JSXSpreadChild: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXSpreadChild.JSXBracket'\n    }\n  },\n  JSXSpreadAttribute: {\n    highlightScope: HIGHLIGHT_TYPE.EDGE,\n    options: {\n      inlineClassName: 'JSXSpreadAttribute.JSXBracket'\n    }\n  },\n  JSXElement: {\n    highlightScope: HIGHLIGHT_TYPE.ELEMENT,\n    options: elementName => ({\n      glyphMarginClassName: 'JSXElement.JSXGlyph',\n      glyphMarginHoverMessage: `JSX Element${elementName ? ': ' + elementName : ''}`\n    })\n  },\n  JSXBracket: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXElement.JSXBracket'\n    },\n    openingElementOptions: {\n      inlineClassName: 'JSXOpeningElement.JSXBracket'\n    },\n    closingElementOptions: {\n      inlineClassName: 'JSXClosingElement.JSXBracket'\n    }\n  },\n  JSXOpeningElement: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXOpeningElement.JSXIdentifier'\n    }\n  },\n  JSXClosingElement: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXClosingElement.JSXIdentifier'\n    }\n  },\n  JSXAttribute: {\n    highlightScope: HIGHLIGHT_TYPE.STYLE,\n    options: {\n      inlineClassName: 'JSXAttribute.JSXIdentifier'\n    }\n  }\n};\n\nclass DecoratorMapper {\n  constructor(monacoEditor, loc2Range, _JSXTypes = JSXTypes) {\n    let decorators = [];\n    let jsxDecoratorIds = [];\n\n    const addDecorator = ([loc, options]) => {\n      return decorators.push({\n        range: loc2Range(loc),\n        options\n      });\n    };\n\n    const deltaDecorations = () => {\n      jsxDecoratorIds = monacoEditor.deltaDecorations(jsxDecoratorIds || [], decorators);\n      decorators = [];\n      return jsxDecoratorIds;\n    };\n\n    this.deltaJSXDecorations = (jsxExpressions, options) => {\n      for (const jsxType in _JSXTypes) {\n        jsxExpressions.filter(path => path.type === jsxType).forEach(path => HIGHLIGHT_MODE[_JSXTypes[jsxType].highlightScope](path, _JSXTypes[jsxType].options, options).forEach(entry => addDecorator(entry)));\n      }\n\n      return deltaDecorations();\n    };\n\n    this.reset = () => {\n      decorators = [];\n      deltaDecorations();\n    };\n\n    this.reset();\n  }\n\n}\n\nconst JSXCommentContexts = {\n  JS: 'JS',\n  JSX: 'JSX'\n};\n\nfunction getJSXContext(jsxExpressions, commentableRange, commentContainingRange, loc2Range) {\n  if (!(jsxExpressions && commentableRange && commentContainingRange && loc2Range)) {\n    return JSXCommentContexts.JS;\n  }\n\n  let minRange = null;\n  let minCommentableRange = null;\n  let path = null;\n  let commentablePath = null;\n  jsxExpressions.forEach(p => {\n    const jsxRange = loc2Range(p.node.loc);\n\n    if ((p.key === 'name' || p.key === 'property') && p.isJSXIdentifier() && jsxRange.intersectRanges(commentableRange)) {\n      if (!minCommentableRange || minCommentableRange.containsRange(jsxRange)) {\n        minCommentableRange = jsxRange;\n        commentablePath = p;\n      }\n    }\n\n    if (jsxRange.intersectRanges(commentContainingRange)) {\n      if (!minRange || minRange.containsRange(jsxRange)) {\n        minRange = jsxRange;\n        path = p;\n      }\n    }\n  });\n\n  if (!path || path.isJSXExpressionContainer() || commentablePath) {\n    return JSXCommentContexts.JS;\n  } else {\n    return JSXCommentContexts.JSX;\n  }\n}\n\nclass Commenter {\n  constructor(monacoEditorManager, parseJSXExpressionsPromise) {\n    let _editorCommandId = null;\n\n    this.getEditorCommandId = () => {\n      return _editorCommandId;\n    };\n\n    let _isJSXCommentCommandActive = false;\n\n    this.isJSXCommentCommandActive = () => {\n      return _isJSXCommentCommandActive;\n    };\n\n    const editorCommandOnDispose = () => {\n      _isJSXCommentCommandActive = false;\n    };\n\n    this.runJsxCommentAction = (selection, commentContext) => {\n      const {\n        monacoEditor,\n        monaco,\n        runEditorCommentLineAction,\n        getSelectionFirstLineText\n      } = monacoEditorManager;\n      const jsCommentText = getSelectionFirstLineText();\n\n      if (jsCommentText.match(/^\\s*\\/[/*]/)) {\n        runEditorCommentLineAction();\n        return;\n      }\n\n      const model = monacoEditor.getModel();\n      let isUnCommentAction = true;\n      const commentsData = [];\n\n      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {\n        const commentRange = new monaco.Range(i, model.getLineFirstNonWhitespaceColumn(i), i, model.getLineMaxColumn(i));\n        const commentText = model.getValueInRange(commentRange);\n        commentsData.push({\n          commentRange,\n          commentText\n        });\n        isUnCommentAction = isUnCommentAction && !!commentText.match(/{\\/\\*/);\n      }\n\n      if (commentContext !== JSXCommentContexts.JSX && !isUnCommentAction) {\n        runEditorCommentLineAction();\n        return;\n      }\n\n      let editOperations = [];\n      let commentsDataIndex = 0;\n\n      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {\n        let {\n          commentText,\n          commentRange\n        } = commentsData[commentsDataIndex++];\n\n        if (isUnCommentAction) {\n          commentText = commentText.replace(/{\\/\\*/, '');\n          commentText = commentText.replace(/\\*\\/}/, '');\n        } else {\n          commentText = `{/*${commentText}*/}`;\n        }\n\n        editOperations.push({\n          identifier: {\n            major: 1,\n            minor: 1\n          },\n          range: commentRange,\n          text: commentText,\n          forceMoveMarkers: true\n        });\n      }\n\n      editOperations.length && monacoEditor.executeEdits(_editorCommandId, editOperations);\n    };\n\n    this.addJSXCommentCommand = () => {\n      const {\n        monacoEditor,\n        monaco,\n        loc2Range,\n        runEditorCommentLineAction,\n        getCommentableStartingRange,\n        getCommentContainingStartingRange\n      } = monacoEditorManager;\n\n      if (_editorCommandId) {\n        _isJSXCommentCommandActive = true;\n        return editorCommandOnDispose;\n      }\n\n      _editorCommandId = monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_SLASH, () => {\n        if (!_isJSXCommentCommandActive) {\n          runEditorCommentLineAction();\n          return;\n        }\n\n        parseJSXExpressionsPromise().then(jsxExpressions => {\n          const selection = monacoEditor.getSelection();\n          const commentContext = getJSXContext(jsxExpressions, getCommentableStartingRange(selection), getCommentContainingStartingRange(selection), loc2Range);\n          this.runJsxCommentAction(selection, commentContext);\n        }).catch(() => {\n          runEditorCommentLineAction();\n        });\n      });\n      _isJSXCommentCommandActive = true;\n      monacoEditor.onDidDispose(editorCommandOnDispose);\n      return editorCommandOnDispose;\n    };\n  }\n\n}\n\nconst defaultOptions = {\n  parser: 'babel',\n  isHighlightGlyph: false,\n  iShowHover: false,\n  isUseSeparateElementStyles: false,\n  jsxCommenter: null,\n  monacoEditorManager: null,\n  decoratorMapper: null\n};\n\nconst makeGetAstPromise = (parse, monacoEditor) => () => {\n  return new Promise((resolve, reject) => {\n    try {\n      return resolve(parse(monacoEditor.getValue()));\n    } catch (e) {\n      return reject(e);\n    }\n  });\n};\n\nconst makeParseJSXExpressionsPromise = (traverse, getAstPromise, _collectJSXExpressions = collectJSXExpressions) => () => {\n  return new Promise((resolve, reject) => {\n    getAstPromise().then(ast => {\n      try {\n        return resolve(_collectJSXExpressions(ast, traverse));\n      } catch (e) {\n        return reject(e);\n      }\n    }).catch(e => reject(e));\n  });\n};\n\nconst makeJSXCommenterBundle = (monaco, parse, traverse, monacoEditor, options = {}) => {\n  const {\n    parserType,\n    jsxCommenter,\n    monacoEditorManager\n  } = options;\n  const range2Loc = configureRange2Loc(parserType);\n  const loc2Range = configureLoc2Range(monaco, parserType);\n  const getAstPromise = makeGetAstPromise(parse, monacoEditor);\n  const parseJSXExpressionsPromise = makeParseJSXExpressionsPromise(traverse, getAstPromise);\n\n  const _monacoEditorManager = monacoEditorManager || new MonacoEditorManager(monacoEditor, monaco, loc2Range);\n\n  const _jsxCommenter = jsxCommenter || new Commenter(_monacoEditorManager, parseJSXExpressionsPromise);\n\n  return [_jsxCommenter, _monacoEditorManager, parseJSXExpressionsPromise, getAstPromise, loc2Range, range2Loc];\n};\n\nconst makeBabelParse = parse => {\n  return (code, options = {}) => {\n    return parse(code, { ...options,\n      sourceType: \"module\",\n      plugins: [\"jsx\"],\n      errorRecovery: true\n    });\n  };\n};\n\nclass MonacoJSXHighlighter {\n  constructor(monaco, parse, traverse, monacoEditor, options = {}) {\n    this.options = { ...defaultOptions,\n      ...options\n    };\n    const {\n      jsxCommenter,\n      monacoEditorManager,\n      decoratorMapper\n    } = this.options;\n    this.babelParse = makeBabelParse(parse);\n    const [_jsxCommenter, _monacoEditorManager, parseJSXExpressionsPromise, getAstPromise, loc2Range, range2Loc] = makeJSXCommenterBundle(monaco, this.babelParse, traverse, monacoEditor, this.options);\n    this.jsxCommenter = jsxCommenter || _jsxCommenter;\n    this.monacoEditorManager = monacoEditorManager || _monacoEditorManager;\n    this.parseJSXExpressionsPromise = parseJSXExpressionsPromise;\n    this.getAstPromise = getAstPromise;\n    this.loc2Range = loc2Range;\n    this.range2Loc = range2Loc;\n    this.addJSXCommentCommand = this.jsxCommenter.addJSXCommentCommand;\n    this.decoratorMapper = decoratorMapper || new DecoratorMapper(monacoEditor, this.loc2Range);\n\n    this.decoratorMapperReset = () => {\n      decoratorMapper.reset();\n    };\n\n    this.highlight = (ast, _collectJSXExpressions = collectJSXExpressions) => {\n      return new Promise((resolve, reject) => {\n        const {\n          decoratorMapper,\n          options\n        } = this;\n        const result = {\n          decoratorMapper,\n          options,\n          ast,\n          jsxExpressions: []\n        };\n\n        if (!ast) {\n          return resolve(result);\n        }\n\n        try {\n          const jsxExpressions = _collectJSXExpressions(ast, traverse);\n\n          decoratorMapper.deltaJSXDecorations(jsxExpressions, options);\n          result.jsxExpressions = jsxExpressions;\n          return resolve(result);\n        } catch (e) {\n          return reject(e);\n        }\n      });\n    };\n\n    this.highlightCode = (afterHighlight = ast => ast, onHighlightError = error => error, getAstPromise = this.getAstPromise, onGetAstError = error => error) => {\n      return getAstPromise().then(ast => {\n        this.highlight(ast).then(afterHighlight).catch(onHighlightError);\n      }).catch(onGetAstError);\n    };\n\n    let _isHighlightBoundToModelContentChanges = false;\n\n    this.isHighlightBoundToModelContentChanges = () => _isHighlightBoundToModelContentChanges;\n\n    this.highlightOnDidChangeModelContent = (debounceTime = 100, afterHighlight = ast => ast, onHighlightError = error => error, getAstPromise = this.getAstPromise, onParseAstError = error => error) => {\n      const highlightCallback = () => {\n        return this.highlightCode(afterHighlight, onHighlightError, getAstPromise, onParseAstError);\n      };\n\n      highlightCallback();\n      let tid = null;\n      let highlighterDisposer = {\n        onDidChangeModelContentDisposer: monacoEditor.onDidChangeModelContent(() => {\n          clearTimeout(tid);\n          tid = setTimeout(highlightCallback, debounceTime);\n        }),\n        onDidChangeModelDisposer: monacoEditor.onDidChangeModel(() => {\n          highlightCallback();\n        })\n      };\n\n      highlighterDisposer.dispose = () => {\n        highlighterDisposer.onDidChangeModelContentDisposer.dispose();\n        highlighterDisposer.onDidChangeModelDisposer.dispose();\n      };\n\n      _isHighlightBoundToModelContentChanges = true;\n\n      const onDispose = () => {\n        this.decoratorMapper.reset();\n\n        if (!_isHighlightBoundToModelContentChanges) {\n          return;\n        }\n\n        _isHighlightBoundToModelContentChanges = false;\n        highlighterDisposer && highlighterDisposer.dispose();\n        highlighterDisposer = null;\n      };\n\n      monacoEditor.onDidDispose(() => {\n        this.decoratorMapper.reset();\n        highlighterDisposer = null;\n        _isHighlightBoundToModelContentChanges = false;\n      });\n      return onDispose;\n    };\n\n    this.highLightOnDidChangeModelContent = this.highlightOnDidChangeModelContent;\n  }\n\n}\n\nexport { COMMENT_ACTION_ID, HIGHLIGHT_MODE, HIGHLIGHT_TYPE, JSXCommentContexts, JSXTypes, MonacoEditorManager, cloneLoc, collectJSXExpressions, configureLoc2Range, configureRange2Loc, MonacoJSXHighlighter as default, extractJSXClosingElement, extractJSXExpressionEdges, extractJSXOpeningElement, getCuratedLoc, getJSXContext, getLoc, isJSXIdentifier, isParentJSXAttribute, makeBabelParse, makeGetAstPromise, makeJSXCommenterBundle, makeParseJSXExpressionsPromise, prepareOptions };","map":{"version":3,"sources":["../../node_modules/style-inject/dist/style-inject.es.js","../../src/utils/babel.js","../../src/utils/monaco.js","../../src/core/DecoratorMapper.js","../../src/core/Commenter.js","../../src/core/MonacoJSXHighlighter.js"],"names":["ref","insertAt","head","document","style","collectJSXExpressions","traverseOptions","jsxExpressions","enter","path","traverse","isJSXIdentifier","isParentJSXAttribute","getLoc","cloneLoc","loc","start","end","getCuratedLoc","extractJSXOpeningElement","openingElement","elementName","startLoc","endLoc","extractJSXClosingElement","closingElement","extractJSXExpressionEdges","innerNode","innerLocKey","innerLoc","startEdgeLoc","endEdgeLoc","COMMENT_ACTION_ID","configureLoc2Range","parserType","startLineOffset","startColumnOffset","endLineOffset","endColumnOffset","monaco","configureRange2Loc","line","column","rangeOrPosition","constructor","loc2Range","lineNumber","range","startColumn","commentableRange","containingRange","model","startLineNumber","jsCommentRange","prepareOptions","jsxTypeOptions","highlighterOptions","hoverMessage","type","HIGHLIGHT_TYPE","ELEMENT","ALL","IDENTIFIER","EDGE","STYLE","HIGHLIGHT_MODE","result","JSXTypes","curatedLoc","options","JSXIdentifier","highlightScope","inlineClassName","JSXOpeningFragment","JSXClosingFragment","JSXText","JSXExpressionContainer","JSXSpreadChild","JSXSpreadAttribute","JSXElement","glyphMarginClassName","glyphMarginHoverMessage","JSXBracket","openingElementOptions","closingElementOptions","JSXOpeningElement","JSXClosingElement","JSXAttribute","_JSXTypes","decorators","jsxDecoratorIds","addDecorator","deltaDecorations","monacoEditor","entry","JSXCommentContexts","JS","JSX","minRange","minCommentableRange","commentablePath","p","jsxRange","_editorCommandId","_isJSXCommentCommandActive","editorCommandOnDispose","getSelectionFirstLineText","jsCommentText","runEditorCommentLineAction","isUnCommentAction","commentsData","i","selection","commentRange","commentText","commentContext","editOperations","commentsDataIndex","identifier","major","minor","text","forceMoveMarkers","getCommentContainingStartingRange","parseJSXExpressionsPromise","getJSXContext","getCommentableStartingRange","defaultOptions","parser","isHighlightGlyph","iShowHover","isUseSeparateElementStyles","jsxCommenter","monacoEditorManager","decoratorMapper","makeGetAstPromise","resolve","parse","reject","makeParseJSXExpressionsPromise","_collectJSXExpressions","getAstPromise","ast","e","makeJSXCommenterBundle","range2Loc","_monacoEditorManager","_jsxCommenter","makeBabelParse","sourceType","plugins","errorRecovery","afterHighlight","onHighlightError","error","onGetAstError","_isHighlightBoundToModelContentChanges","debounceTime","onParseAstError","highlightCallback","tid","highlighterDisposer","onDidChangeModelContentDisposer","clearTimeout","setTimeout","onDidChangeModelDisposer","onDispose"],"mappings":"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","sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// gets JSX expressions within a Babel's AST\nexport const collectJSXExpressions = (ast, traverse, traverseOptions = {}) => {\n   const jsxExpressions = [];\n   \n   const enter = (path) => {\n      if (path.type.toUpperCase().includes(\"JSX\")) {\n         jsxExpressions.push(path);\n      }\n   }\n   \n   traverse(ast, {...traverseOptions, enter});\n   \n   return jsxExpressions;\n}\n\nexport const isJSXIdentifier = (path) => {\n   return (path && (\n         path.key === 'object' ||\n         path.key === 'property' ||\n         path.key === 'name' ||\n         path.key === 'namespace'\n      )\n   );\n}\n\nexport const isParentJSXAttribute = (path) => {\n   return (\n      path &&\n      path.parentPath &&\n      path.parentPath.isJSXAttribute()\n   );\n};\n\nexport const getLoc = (path) => {\n   return (path && path.node && path.node.loc);\n};\n\nexport const cloneLoc = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return null;\n   }\n   \n   return {\n      start: {...loc.start},\n      end: {...loc.end}\n   };\n   \n};\n\n// prevents spilling highlighting on objects props\nexport const getCuratedLoc = (path) => {\n   const loc = cloneLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   if (path.key === 'object' && path.container) {\n      loc.end = {...path.container.property.loc.start};\n   }\n   \n   return loc;\n   \n};\n\nexport const extractJSXOpeningElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const openingElement = path.node.openingElement;\n   \n   if (!openingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = openingElement.name.name;\n   \n   const startLoc = {\n      start: {...openingElement.loc.start},\n      end: {...openingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...openingElement.loc.end},\n      end: {...openingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   if (openingElement.selfClosing) {\n      endLoc.start.column--;\n   }\n   \n   return [openingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXClosingElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const closingElement = path.node.closingElement;\n   \n   if (!closingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = closingElement.name && closingElement.name.name;\n   \n   const startLoc = {\n      start: {...closingElement.loc.start},\n      end: {...closingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...closingElement.loc.end},\n      end: {...closingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   return [closingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXExpressionEdges = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   let innerNode = null;\n   let innerLocKey = path.isJSXSpreadChild() ? 'expression'\n      : path.isJSXSpreadAttribute() ? 'argument'\n         : null;\n   \n   let innerLoc = null;\n   \n   if (innerLocKey) {\n      innerNode = path.node[innerLocKey];\n      \n      innerLoc = {\n         start: {...innerNode.loc.start},\n         end: {...innerNode.loc.end}\n      };\n      \n      if (innerNode.extra && innerNode.extra.parenthesized) {\n         innerLoc.start.column--;\n         innerLoc.end.column++;\n      }\n   } else {\n      innerLoc = {start: {...loc.start}, end: {...loc.end}};\n      innerLoc.start.column++;\n      innerLoc.end.column--;\n   }\n   \n   const startEdgeLoc = {start: {...loc.start}, end: {...innerLoc.start}};\n   \n   const endEdgeLoc = {start: {...innerLoc.end}, end: {...loc.end}};\n   return [innerNode, innerLocKey, startEdgeLoc, endEdgeLoc];\n};\n","export const COMMENT_ACTION_ID = \"editor.action.commentLine\";\n\n// adapts location objects (e.g. Babel uses internally Acorn) to Monaco Ranges\nexport const configureLoc2Range = (\n   monaco, parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            loc,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            if (!loc || !loc.start) {\n               return new monaco.Range(\n                  1,\n                  1,\n                  1,\n                  1\n               );\n            }\n            return new monaco.Range(\n               startLineOffset + loc.start.line,\n               startColumnOffset + loc.start.column + 1,\n               endLineOffset + loc.end ?\n                  loc.end.line\n                  : loc.start.line,\n               endColumnOffset + loc.end ?\n                  loc.end.column + 1\n                  : loc.start.column + 1,\n            );\n         };\n   }\n};\n\nexport const configureRange2Loc = (\n   parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            rangeOrPosition,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            const loc = {\n               start: {line: 0, column: 0},\n               end: {line: 0, column: 0}\n            };\n            \n            if (!rangeOrPosition) {\n               return loc;\n            }\n            \n            // position\n            if (rangeOrPosition.lineNumber) {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.lineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.column - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.lineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.column - 1;\n            } else {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.startLineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.startColumn - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.endLineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.endColumn - 1;\n            }\n            \n            return loc;\n         };\n   }\n};\n\nexport class MonacoEditorManager {\n   constructor(monacoEditor, monaco, loc2Range) {\n      this.monacoEditor = monacoEditor;\n      this.monaco = monaco;\n      this.loc2Range = loc2Range || configureRange2Loc(monaco);\n      \n      // default editor comment action\n      this.runEditorCommentLineAction = () => {\n         return this.monacoEditor\n            .getAction(COMMENT_ACTION_ID)\n            .run();\n      };\n      \n      // preserves indentation when commenting code\n      this.getLineIndentationColumn = (lineNumber) => {\n         return this.monacoEditor\n            .getModel()\n            .getLineFirstNonWhitespaceColumn(\n               lineNumber\n            );\n      };\n      \n      this.getCommentableStartingRange = (range) => {\n         const startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         // creates an anchor to check for comments\n         const commentableRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return commentableRange;\n      };\n      \n      this.getCommentContainingStartingRange = (range) => {\n         // preserves indentation when commenting code\n         let startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         startColumn = startColumn ? startColumn - 1 : 0;\n         const containingRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return containingRange;\n      };\n      \n      this.getSelectionFirstLineText = () => {\n         const model = this.monacoEditor.getModel();\n         const {startLineNumber} = this.monacoEditor.getSelection();\n         \n         const jsCommentRange = new this.monaco.Range(\n            startLineNumber,\n            this.getLineIndentationColumn(\n               startLineNumber\n            ),\n            startLineNumber,\n            model.getLineMaxColumn(startLineNumber),\n         );\n         return model.getValueInRange(jsCommentRange);\n      };\n   }\n}\n","import {\n   extractJSXOpeningElement,\n   extractJSXClosingElement,\n   getLoc,\n   getCuratedLoc,\n   isJSXIdentifier,\n   isParentJSXAttribute,\n   extractJSXExpressionEdges\n} from \"../utils/babel\";\n\nexport const prepareOptions =(\n   path,\n   jsxTypeOptions = {},\n   highlighterOptions = {}\n) =>{\n   return highlighterOptions.iShowHover ?\n      {...jsxTypeOptions, ...{hoverMessage: `(${path.type})`}}\n      : jsxTypeOptions;\n};\n\nexport const HIGHLIGHT_TYPE = {\n   ELEMENT: 'ELEMENT', // jsx elements\n   ALL: 'ALL', // the whole node's location, e.g. identifier names\n   IDENTIFIER: 'IDENTIFIER', // JSX identifiers\n   EDGE: 'EDGE', // only the  starting and ending characters in node's\n   // location e.g. spread child or attribute, container expressions\n   STYLE: 'STYLE', // for styling only, not used by node locations\n};\n\n\nexport const HIGHLIGHT_MODE = {\n   /**\n    *  ALL functions follow this signature:\n    *  @param {Babel Path} - the path to process.\n    *  @param {Object} jsxTypeOptions - the Monaco Decorator options to be used.\n    *  @param {Object} highlighterOptions - this library configuration for\n    *  highlighting.\n    *  @returns {Array} a collection JSX entries, each entry is an array too:\n    *  0: location object matching Babel's Location structure.\n    *  1: JSXTypes' Monaco options to create a highlighting  decorator.\n    *  Note: Purposely array entries to prevent using them directly with\n    Monaco without properly adapting Babel locations to Monaco Ranges.\n    **/\n   [HIGHLIGHT_TYPE.ELEMENT]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const [\n         openingElement, elementName, startLoc, endLoc\n      ] = extractJSXOpeningElement(path);\n      \n      const result = [];\n      \n      if (openingElement) {\n         result.push([\n            startLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         \n         result.push([\n            endLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const [\n         closingElement, , closingElementStartLoc, closingElementEndLoc\n      ] = extractJSXClosingElement(path);\n      \n      if (closingElement) {\n         result.push([\n            closingElementStartLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         result.push([\n            closingElementEndLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const loc = getLoc(path);\n      highlighterOptions.isHighlightGlyph && result.push([\n         loc,\n         JSXTypes.JSXElement.options(elementName)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.ALL]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const curatedLoc = getCuratedLoc(path);\n      const result = [];\n      curatedLoc && result.push([\n         curatedLoc,\n         prepareOptions(path, jsxTypeOptions, highlighterOptions)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.IDENTIFIER]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      if (!isJSXIdentifier(path)) {\n         return [];\n      }\n      \n      return HIGHLIGHT_MODE[HIGHLIGHT_TYPE.ALL](\n         path,\n         isParentJSXAttribute(path) ?\n            JSXTypes.JSXAttribute.options : jsxTypeOptions,\n         highlighterOptions,\n      );\n   },\n   [HIGHLIGHT_TYPE.EDGE]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const options = prepareOptions(path, jsxTypeOptions, highlighterOptions);\n      \n      const [\n         , , startEdgeLoc, endEdgeLoc\n      ] = extractJSXExpressionEdges(path);\n      \n      const result = [];\n      \n      result.push([\n         startEdgeLoc,\n         options\n      ]);\n      result.push([\n         endEdgeLoc,\n         options\n      ]);\n      \n      return result;\n      \n   },\n   [HIGHLIGHT_TYPE.STYLE]: () => [], // noop\n};\n\nexport const JSXTypes = {\n   JSXIdentifier: {\n      highlightScope: HIGHLIGHT_TYPE.IDENTIFIER,\n      options: {\n         inlineClassName: 'JSXElement.JSXIdentifier',\n      },\n   },\n   JSXOpeningFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXOpeningFragment.JSXBracket',\n      },\n   },\n   JSXClosingFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXClosingFragment.JSXBracket',\n      },\n   },\n   JSXText: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXElement.JSXText',\n      },\n   },\n   JSXExpressionContainer: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXExpressionContainer.JSXBracket',\n      },\n   },\n   JSXSpreadChild: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadChild.JSXBracket',\n      },\n   },\n   JSXSpreadAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadAttribute.JSXBracket',\n      },\n   },\n   JSXElement: {\n      highlightScope: HIGHLIGHT_TYPE.ELEMENT, //HIGHLIGHT_TYPE.STYLE,\n      options: (elementName) => (\n         {\n            glyphMarginClassName: 'JSXElement.JSXGlyph',\n            glyphMarginHoverMessage:\n               `JSX Element${elementName ? ': ' + elementName : ''}`\n         }\n      ),\n   },\n   JSXBracket: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXElement.JSXBracket',\n      },\n      openingElementOptions: {\n         inlineClassName: 'JSXOpeningElement.JSXBracket',\n      },\n      closingElementOptions: {\n         inlineClassName: 'JSXClosingElement.JSXBracket',\n      },\n   },\n   JSXOpeningElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXOpeningElement.JSXIdentifier',\n      },\n   },\n   JSXClosingElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXClosingElement.JSXIdentifier',\n      },\n   },\n   JSXAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXAttribute.JSXIdentifier',\n      },\n   },\n};\n\nclass DecoratorMapper {\n   constructor(monacoEditor, loc2Range, _JSXTypes = JSXTypes) {\n      let decorators = [];\n      let jsxDecoratorIds = [];\n      \n      const addDecorator = ([loc, options]) => {\n         return decorators.push({\n            range: loc2Range(loc),\n            options\n         });\n      }\n      \n      const deltaDecorations = () => {\n         jsxDecoratorIds =\n            monacoEditor.deltaDecorations(\n               jsxDecoratorIds || [],\n               decorators\n            );\n         decorators = [];\n         return jsxDecoratorIds;\n      }\n      \n      this.deltaJSXDecorations = (jsxExpressions, options) => {\n         for (const jsxType in _JSXTypes) {\n            jsxExpressions.filter(path => path.type === jsxType)\n               .forEach(path =>\n                  HIGHLIGHT_MODE[_JSXTypes[jsxType].highlightScope](\n                     path,\n                     _JSXTypes[jsxType].options,\n                     options,\n                  ).forEach(entry => addDecorator(entry))\n               );\n         }\n         \n         return deltaDecorations();\n      }\n      \n      this.reset = () => {\n         decorators = [];\n         deltaDecorations();\n      }\n      \n      this.reset();\n   }\n}\n\nexport default DecoratorMapper;\n","export const JSXCommentContexts = {\n   JS: 'JS',\n   JSX: 'JSX'\n}\n\nexport function getJSXContext(\n   jsxExpressions,\n   commentableRange,\n   commentContainingRange,\n   loc2Range\n) {\n   if (!(jsxExpressions &&\n      commentableRange &&\n      commentContainingRange &&\n      loc2Range)) {\n      return JSXCommentContexts.JS;\n   }\n   \n   \n   let minRange = null;\n   let minCommentableRange = null;\n   let path = null;\n   let commentablePath = null;\n   \n   jsxExpressions.forEach(p => {\n      const jsxRange = loc2Range(p.node.loc);\n      if ((p.key === 'name' || p.key === 'property') &&\n         p.isJSXIdentifier() &&\n         jsxRange.intersectRanges(commentableRange)) {\n         if (\n            !minCommentableRange ||\n            minCommentableRange.containsRange(jsxRange)\n         ) {\n            minCommentableRange = jsxRange;\n            commentablePath = p;\n         }\n      }\n      if (jsxRange.intersectRanges(commentContainingRange)) {\n         if (!minRange || minRange.containsRange(jsxRange)) {\n            minRange = jsxRange;\n            path = p;\n         }\n      }\n   });\n   \n   if (!path || path.isJSXExpressionContainer() || commentablePath) {\n      return JSXCommentContexts.JS;\n   } else {\n      return JSXCommentContexts.JSX;\n   }\n}\n\nclass Commenter {\n   constructor(\n      monacoEditorManager,\n      parseJSXExpressionsPromise\n   ) {\n      \n      let _editorCommandId = null;\n      \n      this.getEditorCommandId = () => {\n         return _editorCommandId;\n      }\n      \n      let _isJSXCommentCommandActive = false;\n      \n      this.isJSXCommentCommandActive = () => {\n         return _isJSXCommentCommandActive;\n      }\n      \n      const editorCommandOnDispose = () => {\n         _isJSXCommentCommandActive = false;\n      };\n      \n      this.runJsxCommentAction = (selection, commentContext) => {\n         const {\n            monacoEditor, monaco, runEditorCommentLineAction,\n            getSelectionFirstLineText,\n         } = monacoEditorManager;\n         \n         const jsCommentText = getSelectionFirstLineText();\n         \n         if (jsCommentText.match(/^\\s*\\/[/*]/)) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         const model = monacoEditor.getModel();\n         \n         let isUnCommentAction = true;\n         const commentsData = [];\n         \n         for (\n            let i = selection.startLineNumber; i <= selection.endLineNumber; i++\n         ) {\n            const commentRange = new monaco.Range(\n               i,\n               model.getLineFirstNonWhitespaceColumn(i),\n               i,\n               model.getLineMaxColumn(i),\n            );\n            \n            const commentText = model.getValueInRange(commentRange);\n            \n            commentsData.push({\n               commentRange,\n               commentText\n            });\n            \n            isUnCommentAction = isUnCommentAction &&\n               !!commentText.match(/{\\/\\*/);\n         }\n         \n         if (commentContext !== JSXCommentContexts.JSX\n            && !isUnCommentAction) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         let editOperations = [];\n         let commentsDataIndex = 0;\n         \n         for (let i = selection.startLineNumber;\n              i <= selection.endLineNumber;\n              i++) {\n            let {\n               commentText,\n               commentRange,\n            } = commentsData[commentsDataIndex++];\n            \n            if (isUnCommentAction) {\n               commentText = commentText.replace(/{\\/\\*/, '');\n               commentText = commentText.replace(/\\*\\/}/, '');\n            } else {\n               commentText = `{/*${commentText}*/}`;\n            }\n            \n            editOperations.push({\n               identifier: {major: 1, minor: 1},\n               range: commentRange,\n               text: commentText,\n               forceMoveMarkers: true,\n            });\n         }\n         editOperations.length &&\n         monacoEditor.executeEdits(_editorCommandId, editOperations);\n      }\n      \n      this.addJSXCommentCommand = () => {\n         const {\n            monacoEditor, monaco, loc2Range, runEditorCommentLineAction,\n            getCommentableStartingRange, getCommentContainingStartingRange\n         } = monacoEditorManager;\n         \n         if (_editorCommandId) {\n            _isJSXCommentCommandActive = true;\n            return editorCommandOnDispose;\n         }\n         \n         _editorCommandId = monacoEditor.addCommand(\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_SLASH,\n            () => {\n               if (!_isJSXCommentCommandActive) {\n                  runEditorCommentLineAction();\n                  return;\n               }\n               \n               parseJSXExpressionsPromise()\n                  .then(jsxExpressions => {\n                     const selection = monacoEditor.getSelection();\n                     const commentContext = getJSXContext(\n                        jsxExpressions,\n                        getCommentableStartingRange(selection),\n                        getCommentContainingStartingRange(selection),\n                        loc2Range\n                     );\n                     this.runJsxCommentAction(selection, commentContext);\n                  }).catch(()=>{\n                   runEditorCommentLineAction();\n               });\n            });\n         \n         _isJSXCommentCommandActive = true;\n         \n         monacoEditor.onDidDispose(editorCommandOnDispose);\n         \n         return editorCommandOnDispose;\n      }\n   }\n}\n\nexport default Commenter;\n","import {\n   configureLoc2Range,\n   configureRange2Loc,\n   MonacoEditorManager\n} from '../utils/monaco';\nimport {collectJSXExpressions} from '../utils/babel';\nimport DecoratorMapper from './DecoratorMapper';\nimport Commenter from './Commenter';\n\nconst defaultOptions = {\n   parser: 'babel',\n   isHighlightGlyph: false,\n   iShowHover: false,\n   isUseSeparateElementStyles: false,\n   jsxCommenter: null,\n   monacoEditorManager: null,\n   decoratorMapper: null,\n};\n\nexport const makeGetAstPromise = (parse, monacoEditor) => () => {\n   return new Promise(\n      (resolve, reject) => {\n         try {\n            return resolve(\n               parse(monacoEditor.getValue()) // ast\n            );\n         } catch (e) {\n            return reject(e);\n         }\n      }\n   );\n};\n\nexport const makeParseJSXExpressionsPromise = (\n   traverse, getAstPromise, _collectJSXExpressions = collectJSXExpressions\n) => () => {\n   return new Promise((resolve, reject) => {\n      getAstPromise()\n         .then(ast => {\n               try {\n                  return resolve(\n                     _collectJSXExpressions(ast, traverse)\n                  );\n               } catch (e) {\n                  return reject(e);\n               }\n            }\n         ).catch(e => reject(e));\n   });\n};\n\nexport const makeJSXCommenterBundle = (\n   monaco, parse, traverse, monacoEditor, options = {}\n) => {\n   const {parserType, jsxCommenter, monacoEditorManager} = options;\n   const range2Loc = configureRange2Loc(parserType);\n   const loc2Range = configureLoc2Range(monaco, parserType);\n   \n   const getAstPromise = makeGetAstPromise(parse, monacoEditor);\n   \n   const parseJSXExpressionsPromise = makeParseJSXExpressionsPromise(\n      traverse, getAstPromise\n   );\n   \n   const _monacoEditorManager = monacoEditorManager ||\n      new MonacoEditorManager(monacoEditor, monaco, loc2Range);\n   \n   const _jsxCommenter = jsxCommenter || new Commenter(\n      _monacoEditorManager, parseJSXExpressionsPromise\n   );\n   \n   return [\n      _jsxCommenter, _monacoEditorManager,\n      parseJSXExpressionsPromise, getAstPromise,\n      loc2Range, range2Loc\n   ];\n};\n\n// Minimal Babel setup for React JSX parsing:\nexport const makeBabelParse = (parse) => {\n   return (code, options = {}) => {\n      return parse(\n         code,\n         {\n            ...options,\n            sourceType: \"module\",\n            plugins: [\"jsx\"],\n            errorRecovery: true\n         });\n      \n   };\n};\n\nclass MonacoJSXHighlighter {\n   constructor(\n      monaco,\n      parse,\n      traverse,\n      monacoEditor,\n      options = {}\n   ) {\n      this.options = {...defaultOptions, ...options};\n      \n      const {jsxCommenter, monacoEditorManager, decoratorMapper} = this.options;\n      \n      this.babelParse = makeBabelParse(parse);\n      \n      const [\n         _jsxCommenter, _monacoEditorManager,\n         parseJSXExpressionsPromise, getAstPromise,\n         loc2Range, range2Loc\n      ] = makeJSXCommenterBundle(\n         monaco, this.babelParse, traverse, monacoEditor, this.options\n      );\n      \n      this.jsxCommenter = jsxCommenter || _jsxCommenter;\n      this.monacoEditorManager = monacoEditorManager || _monacoEditorManager;\n      this.parseJSXExpressionsPromise = parseJSXExpressionsPromise;\n      this.getAstPromise = getAstPromise;\n      this.loc2Range = loc2Range;\n      this.range2Loc = range2Loc;\n      \n      this.addJSXCommentCommand = this.jsxCommenter.addJSXCommentCommand;\n      \n      \n      this.decoratorMapper = decoratorMapper ||\n         new DecoratorMapper(monacoEditor, this.loc2Range);\n      this.decoratorMapperReset = () => {\n         decoratorMapper.reset()\n      };\n      \n      this.highlight = (\n         ast, _collectJSXExpressions = collectJSXExpressions\n      ) => {\n         return new Promise((resolve, reject) => {\n            const {decoratorMapper, options} = this;\n            const result = {\n               decoratorMapper,\n               options,\n               ast,\n               jsxExpressions: [],\n            };\n            \n            //ignore update if parsing was unsuccessful\n            if (!ast) {\n               return resolve(result);\n            }\n            \n            try {\n               const jsxExpressions = _collectJSXExpressions(ast, traverse);\n               \n               decoratorMapper.deltaJSXDecorations(\n                  jsxExpressions, options\n               );\n               \n               result.jsxExpressions = jsxExpressions;\n               \n               return resolve(result);\n            } catch (e) {\n               return reject(e);\n            }\n         });\n      };\n      \n      this.highlightCode = (\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onGetAstError = error => error,\n      ) => {\n         return (\n            getAstPromise()\n               .then(ast => {\n                  this.highlight(ast)\n                     .then(afterHighlight)\n                     .catch(onHighlightError)\n               })\n               .catch(onGetAstError)\n         );\n      };\n      \n      let _isHighlightBoundToModelContentChanges = false;\n      \n      this.isHighlightBoundToModelContentChanges =\n         () => _isHighlightBoundToModelContentChanges;\n      \n      this.highlightOnDidChangeModelContent = (\n         debounceTime = 100,\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onParseAstError = error => error,\n      ) => {\n         const highlightCallback = () => {\n            return this.highlightCode(\n               afterHighlight,\n               onHighlightError,\n               getAstPromise,\n               onParseAstError\n            );\n         };\n         \n         highlightCallback();\n         \n         let tid = null;\n         \n         let highlighterDisposer = {\n            onDidChangeModelContentDisposer:\n               monacoEditor.onDidChangeModelContent(\n                  () => {\n                     clearTimeout(tid);\n                     tid = setTimeout(\n                        highlightCallback,\n                        debounceTime\n                     );\n                  }),\n            onDidChangeModelDisposer: monacoEditor.onDidChangeModel(\n               () => {\n                  highlightCallback();\n               })\n         };\n         \n         highlighterDisposer.dispose = () => {\n            highlighterDisposer.onDidChangeModelContentDisposer.dispose();\n            highlighterDisposer.onDidChangeModelDisposer.dispose();\n         };\n         \n         _isHighlightBoundToModelContentChanges = true;\n         \n         const onDispose = () => {\n            this.decoratorMapper.reset();\n            if (\n               !_isHighlightBoundToModelContentChanges\n            ) {\n               return;\n            }\n            _isHighlightBoundToModelContentChanges = false;\n            highlighterDisposer && highlighterDisposer.dispose();\n            highlighterDisposer = null;\n            \n         }\n         \n         monacoEditor.onDidDispose(() => {\n            this.decoratorMapper.reset();\n            highlighterDisposer = null;\n            _isHighlightBoundToModelContentChanges = false;\n         });\n         \n         \n         return onDispose;\n      };\n      \n      // backwards compatible typo preserve to avoid breaking changes\n      this.highLightOnDidChangeModelContent =\n         this.highlightOnDidChangeModelContent;\n   }\n}\n\n// use .polyfilled dist when usign node < 10. // .babelrc.json:  \"node\": \"0\"\nexport default MonacoJSXHighlighter;\n"]},"metadata":{},"sourceType":"module"}