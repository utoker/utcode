{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/utoker/Projects/utcode/packages/local-client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SCIENTIFIC_NOTATION = /e/i;\nvar ZERO_DECIMAL_INTEGER = /\\.0+$/;\nvar NON_DECIMAL_LITERAL = /^0[box]/;\nvar PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nvar Printer = /*#__PURE__*/function () {\n  function Printer(format, map) {\n    _classCallCheck(this, Printer);\n\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  _createClass(Printer, [{\n    key: \"generate\",\n    value: function generate(ast) {\n      this.print(ast);\n\n      this._maybeAddAuxComment();\n\n      return this._buf.get();\n    }\n  }, {\n    key: \"indent\",\n    value: function indent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent++;\n    }\n  }, {\n    key: \"dedent\",\n    value: function dedent() {\n      if (this.format.compact || this.format.concise) return;\n      this._indent--;\n    }\n  }, {\n    key: \"semicolon\",\n    value: function semicolon() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._maybeAddAuxComment();\n\n      this._append(\";\", !force);\n    }\n  }, {\n    key: \"rightBrace\",\n    value: function rightBrace() {\n      if (this.format.minified) {\n        this._buf.removeLastSemicolon();\n      }\n\n      this.token(\"}\");\n    }\n  }, {\n    key: \"space\",\n    value: function space() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.format.compact) return;\n\n      if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n        this._space();\n      }\n    }\n  }, {\n    key: \"word\",\n    value: function word(str) {\n      if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n        this._space();\n      }\n\n      this._maybeAddAuxComment();\n\n      this._append(str);\n\n      this._endsWithWord = true;\n    }\n  }, {\n    key: \"number\",\n    value: function number(str) {\n      this.word(str);\n      this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n    }\n  }, {\n    key: \"token\",\n    value: function token(str) {\n      if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n        this._space();\n      }\n\n      this._maybeAddAuxComment();\n\n      this._append(str);\n    }\n  }, {\n    key: \"newline\",\n    value: function newline(i) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n\n      if (this.endsWith(\"\\n\\n\")) return;\n      if (typeof i !== \"number\") i = 1;\n      i = Math.min(2, i);\n      if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n      if (i <= 0) return;\n\n      for (var j = 0; j < i; j++) {\n        this._newline();\n      }\n    }\n  }, {\n    key: \"endsWith\",\n    value: function endsWith(str) {\n      return this._buf.endsWith(str);\n    }\n  }, {\n    key: \"removeTrailingNewline\",\n    value: function removeTrailingNewline() {\n      this._buf.removeTrailingNewline();\n    }\n  }, {\n    key: \"exactSource\",\n    value: function exactSource(loc, cb) {\n      this._catchUp(\"start\", loc);\n\n      this._buf.exactSource(loc, cb);\n    }\n  }, {\n    key: \"source\",\n    value: function source(prop, loc) {\n      this._catchUp(prop, loc);\n\n      this._buf.source(prop, loc);\n    }\n  }, {\n    key: \"withSource\",\n    value: function withSource(prop, loc, cb) {\n      this._catchUp(prop, loc);\n\n      this._buf.withSource(prop, loc, cb);\n    }\n  }, {\n    key: \"_space\",\n    value: function _space() {\n      this._append(\" \", true);\n    }\n  }, {\n    key: \"_newline\",\n    value: function _newline() {\n      this._append(\"\\n\", true);\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(str) {\n      var queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._maybeAddParen(str);\n\n      this._maybeIndent(str);\n\n      if (queue) this._buf.queue(str);else this._buf.append(str);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n    }\n  }, {\n    key: \"_maybeIndent\",\n    value: function _maybeIndent(str) {\n      if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n        this._buf.queue(this._getIndent());\n      }\n    }\n  }, {\n    key: \"_maybeAddParen\",\n    value: function _maybeAddParen(str) {\n      var parenPushNewlineState = this._parenPushNewlineState;\n      if (!parenPushNewlineState) return;\n      var i;\n\n      for (i = 0; i < str.length && str[i] === \" \"; i++) {\n        continue;\n      }\n\n      if (i === str.length) {\n        return;\n      }\n\n      var cha = str[i];\n\n      if (cha !== \"\\n\") {\n        if (cha !== \"/\" || i + 1 === str.length) {\n          this._parenPushNewlineState = null;\n          return;\n        }\n\n        var chaPost = str[i + 1];\n\n        if (chaPost === \"*\") {\n          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n            return;\n          }\n        } else if (chaPost !== \"/\") {\n          this._parenPushNewlineState = null;\n          return;\n        }\n      }\n\n      this.token(\"(\");\n      this.indent();\n      parenPushNewlineState.printed = true;\n    }\n  }, {\n    key: \"_catchUp\",\n    value: function _catchUp(prop, loc) {\n      if (!this.format.retainLines) return;\n      var pos = loc ? loc[prop] : null;\n\n      if ((pos == null ? void 0 : pos.line) != null) {\n        var count = pos.line - this._buf.getCurrentLine();\n\n        for (var i = 0; i < count; i++) {\n          this._newline();\n        }\n      }\n    }\n  }, {\n    key: \"_getIndent\",\n    value: function _getIndent() {\n      return this.format.indent.style.repeat(this._indent);\n    }\n  }, {\n    key: \"startTerminatorless\",\n    value: function startTerminatorless() {\n      var isLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (isLabel) {\n        this._noLineTerminator = true;\n        return null;\n      } else {\n        return this._parenPushNewlineState = {\n          printed: false\n        };\n      }\n    }\n  }, {\n    key: \"endTerminatorless\",\n    value: function endTerminatorless(state) {\n      this._noLineTerminator = false;\n\n      if (state == null ? void 0 : state.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }, {\n    key: \"print\",\n    value: function print(node, parent) {\n      var _this = this;\n\n      if (!node) return;\n      var oldConcise = this.format.concise;\n\n      if (node._compact) {\n        this.format.concise = true;\n      }\n\n      var printMethod = this[node.type];\n\n      if (!printMethod) {\n        throw new ReferenceError(\"unknown node of type \".concat(JSON.stringify(node.type), \" with constructor \").concat(JSON.stringify(node == null ? void 0 : node.constructor.name)));\n      }\n\n      this._printStack.push(node);\n\n      var oldInAux = this._insideAux;\n      this._insideAux = !node.loc;\n\n      this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n      var needsParens = n.needsParens(node, parent, this._printStack);\n\n      if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n        needsParens = true;\n      }\n\n      if (needsParens) this.token(\"(\");\n\n      this._printLeadingComments(node);\n\n      var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n      this.withSource(\"start\", loc, function () {\n        printMethod.call(_this, node, parent);\n      });\n\n      this._printTrailingComments(node);\n\n      if (needsParens) this.token(\")\");\n\n      this._printStack.pop();\n\n      this.format.concise = oldConcise;\n      this._insideAux = oldInAux;\n    }\n  }, {\n    key: \"_maybeAddAuxComment\",\n    value: function _maybeAddAuxComment(enteredPositionlessNode) {\n      if (enteredPositionlessNode) this._printAuxBeforeComment();\n      if (!this._insideAux) this._printAuxAfterComment();\n    }\n  }, {\n    key: \"_printAuxBeforeComment\",\n    value: function _printAuxBeforeComment() {\n      if (this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = true;\n      var comment = this.format.auxiliaryCommentBefore;\n\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        });\n      }\n    }\n  }, {\n    key: \"_printAuxAfterComment\",\n    value: function _printAuxAfterComment() {\n      if (!this._printAuxAfterOnNextUserNode) return;\n      this._printAuxAfterOnNextUserNode = false;\n      var comment = this.format.auxiliaryCommentAfter;\n\n      if (comment) {\n        this._printComment({\n          type: \"CommentBlock\",\n          value: comment\n        });\n      }\n    }\n  }, {\n    key: \"getPossibleRaw\",\n    value: function getPossibleRaw(node) {\n      var extra = node.extra;\n\n      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n        return extra.raw;\n      }\n    }\n  }, {\n    key: \"printJoin\",\n    value: function printJoin(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!(nodes == null ? void 0 : nodes.length)) return;\n      if (opts.indent) this.indent();\n      var newlineOpts = {\n        addNewlines: opts.addNewlines\n      };\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (!node) continue;\n        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n        this.print(node, parent);\n\n        if (opts.iterator) {\n          opts.iterator(node, i);\n        }\n\n        if (opts.separator && i < nodes.length - 1) {\n          opts.separator.call(this);\n        }\n\n        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n      }\n\n      if (opts.indent) this.dedent();\n    }\n  }, {\n    key: \"printAndIndentOnComments\",\n    value: function printAndIndentOnComments(node, parent) {\n      var indent = node.leadingComments && node.leadingComments.length > 0;\n      if (indent) this.indent();\n      this.print(node, parent);\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"printBlock\",\n    value: function printBlock(parent) {\n      var node = parent.body;\n\n      if (!t.isEmptyStatement(node)) {\n        this.space();\n      }\n\n      this.print(node, parent);\n    }\n  }, {\n    key: \"_printTrailingComments\",\n    value: function _printTrailingComments(node) {\n      this._printComments(this._getComments(false, node));\n    }\n  }, {\n    key: \"_printLeadingComments\",\n    value: function _printLeadingComments(node) {\n      this._printComments(this._getComments(true, node), true);\n    }\n  }, {\n    key: \"printInnerComments\",\n    value: function printInnerComments(node) {\n      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _node$innerComments;\n\n      if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;\n      if (indent) this.indent();\n\n      this._printComments(node.innerComments);\n\n      if (indent) this.dedent();\n    }\n  }, {\n    key: \"printSequence\",\n    value: function printSequence(nodes, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.statement = true;\n      return this.printJoin(nodes, parent, opts);\n    }\n  }, {\n    key: \"printList\",\n    value: function printList(items, parent) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (opts.separator == null) {\n        opts.separator = commaSeparator;\n      }\n\n      return this.printJoin(items, parent, opts);\n    }\n  }, {\n    key: \"_printNewline\",\n    value: function _printNewline(leading, node, parent, opts) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n\n      var lines = 0;\n\n      if (this._buf.hasContent()) {\n        if (!leading) lines++;\n        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n        var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n        if (needs(node, parent)) lines++;\n      }\n\n      this.newline(lines);\n    }\n  }, {\n    key: \"_getComments\",\n    value: function _getComments(leading, node) {\n      return node && (leading ? node.leadingComments : node.trailingComments) || [];\n    }\n  }, {\n    key: \"_printComment\",\n    value: function _printComment(comment, skipNewLines) {\n      var _this2 = this;\n\n      if (!this.format.shouldPrintComment(comment.value)) return;\n      if (comment.ignore) return;\n      if (this._printedComments.has(comment)) return;\n\n      this._printedComments.add(comment);\n\n      if (comment.start != null) {\n        if (this._printedCommentStarts[comment.start]) return;\n        this._printedCommentStarts[comment.start] = true;\n      }\n\n      var isBlockComment = comment.type === \"CommentBlock\";\n      var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n      if (printNewLines && this._buf.hasContent()) this.newline(1);\n      if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n      var val = !isBlockComment && !this._noLineTerminator ? \"//\".concat(comment.value, \"\\n\") : \"/*\".concat(comment.value, \"*/\");\n\n      if (isBlockComment && this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n\n        var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n        if (offset) {\n          var newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        var indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n        val = val.replace(/\\n(?!$)/g, \"\\n\".concat(\" \".repeat(indentSize)));\n      }\n\n      if (this.endsWith(\"/\")) this._space();\n      this.withSource(\"start\", comment.loc, function () {\n        _this2._append(val);\n      });\n      if (printNewLines) this.newline(1);\n    }\n  }, {\n    key: \"_printComments\",\n    value: function _printComments(comments, inlinePureAnnotation) {\n      if (!(comments == null ? void 0 : comments.length)) return;\n\n      if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n        this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n      } else {\n        var _iterator = _createForOfIteratorHelper(comments),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var comment = _step.value;\n\n            this._printComment(comment);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n  }, {\n    key: \"printAssertions\",\n    value: function printAssertions(node) {\n      var _node$assertions;\n\n      if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {\n        this.space();\n        this.word(\"assert\");\n        this.space();\n        this.token(\"{\");\n        this.space();\n        this.printList(node.assertions, node);\n        this.space();\n        this.token(\"}\");\n      }\n    }\n  }]);\n\n  return Printer;\n}();\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":{"version":3,"sources":["/home/utoker/Projects/utcode/packages/local-client/node_modules/@babel/generator/lib/printer.js"],"names":["Object","defineProperty","exports","value","default","_buffer","_interopRequireDefault","require","n","_interopRequireWildcard","t","generatorFunctions","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","Printer","format","map","inForStatementInitCounter","_printStack","_indent","_insideAux","_printedCommentStarts","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","WeakSet","_endsWithInteger","_endsWithWord","_buf","ast","print","_maybeAddAuxComment","compact","concise","force","_append","minified","removeLastSemicolon","token","hasContent","endsWith","_space","str","indexOf","word","Number","isInteger","test","length","i","retainLines","space","Math","min","j","_newline","removeTrailingNewline","loc","cb","_catchUp","exactSource","prop","source","withSource","queue","_maybeAddParen","_maybeIndent","append","_getIndent","parenPushNewlineState","cha","chaPost","slice","indent","printed","pos","line","count","getCurrentLine","style","repeat","isLabel","state","dedent","newline","node","parent","oldConcise","_compact","printMethod","type","ReferenceError","JSON","stringify","constructor","name","push","oldInAux","needsParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","isProgram","isFile","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","raw","rawValue","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","leadingComments","body","isEmptyStatement","_printComments","_getComments","_node$innerComments","innerComments","printJoin","items","commaSeparator","leading","lines","needs","needsWhitespaceBefore","needsWhitespaceAfter","trailingComments","skipNewLines","shouldPrintComment","ignore","add","start","isBlockComment","printNewLines","val","adjustMultilineComment","_comment$loc","offset","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","comments","inlinePureAnnotation","_node$assertions","assertions","printList","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  }\n\n  token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state == null ? void 0 : state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes == null ? void 0 : nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    if (comment.start != null) {\n      if (this._printedCommentStarts[comment.start]) return;\n      this._printedCommentStarts[comment.start] = true;\n    }\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments == null ? void 0 : comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}"]},"metadata":{},"sourceType":"script"}