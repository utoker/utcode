{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.list = exports.nodes = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction crawl(node, state = {}) {\n  if (t.isMemberExpression(node) || t.isOptionalMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node) || t.isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n\n  LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (t.isFunction(node.callee)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) == null ? void 0 : _parent$properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) == null ? void 0 : _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) == null ? void 0 : _parent$callPropertie.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) == null ? void 0 : _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) == null ? void 0 : _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) == null ? void 0 : _parent$indexers.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nconst list = {\n  VariableDeclaration(node) {\n    return node.declarations.map(decl => decl.init);\n  },\n\n  ArrayExpression(node) {\n    return node.elements;\n  },\n\n  ObjectExpression(node) {\n    return node.properties;\n  }\n\n};\nexports.list = list;\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});","map":{"version":3,"sources":["/home/utoker/Projects/utcode/packages/local-client/node_modules/@babel/generator/lib/node/whitespace.js"],"names":["Object","defineProperty","exports","value","list","nodes","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","crawl","node","state","isMemberExpression","isOptionalMemberExpression","object","computed","property","isBinary","isAssignmentExpression","left","right","isCallExpression","isOptionalCallExpression","hasCall","callee","isFunction","hasFunction","isIdentifier","hasHelper","isHelper","name","isType","isLiteral","isObjectExpression","isArrayExpression","AssignmentExpression","before","after","SwitchCase","parent","consequent","length","cases","LogicalExpression","Literal","CallExpression","OptionalCallExpression","VariableDeclaration","i","declarations","declar","enabled","id","init","IfStatement","isBlockStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","properties","ObjectTypeCallProperty","_parent$properties","callProperties","ObjectTypeIndexer","_parent$properties2","_parent$callPropertie","indexers","ObjectTypeInternalSlot","_parent$properties3","_parent$callPropertie2","_parent$indexers","internalSlots","map","decl","ArrayExpression","elements","ObjectExpression","forEach","type","amounts","concat","FLIPPED_ALIAS_KEYS"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.list = exports.nodes = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction crawl(node, state = {}) {\n  if (t.isMemberExpression(node) || t.isOptionalMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node) || t.isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n\n  LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (t.isFunction(node.callee)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) == null ? void 0 : _parent$properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) == null ? void 0 : _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) == null ? void 0 : _parent$callPropertie.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) == null ? void 0 : _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) == null ? void 0 : _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) == null ? void 0 : _parent$indexers.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nconst list = {\n  VariableDeclaration(node) {\n    return node.declarations.map(decl => decl.init);\n  },\n\n  ArrayExpression(node) {\n    return node.elements;\n  },\n\n  ObjectExpression(node) {\n    return node.properties;\n  }\n\n};\nexports.list = list;\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});"]},"metadata":{},"sourceType":"script"}