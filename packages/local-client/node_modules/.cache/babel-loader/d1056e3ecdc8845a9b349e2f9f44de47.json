{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  }\n\n  token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state == null ? void 0 : state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes == null ? void 0 : nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    if (comment.start != null) {\n      if (this._printedCommentStarts[comment.start]) return;\n      this._printedCommentStarts[comment.start] = true;\n    }\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments == null ? void 0 : comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":{"version":3,"sources":["/home/utoker/Projects/utcode/packages/local-client/node_modules/@babel/generator/lib/printer.js"],"names":["Object","defineProperty","exports","value","default","_buffer","_interopRequireDefault","require","n","_interopRequireWildcard","t","generatorFunctions","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_insideAux","_printedCommentStarts","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","WeakSet","_endsWithInteger","_endsWithWord","_buf","generate","ast","print","_maybeAddAuxComment","indent","compact","concise","dedent","semicolon","force","_append","rightBrace","minified","removeLastSemicolon","token","space","hasContent","endsWith","_space","word","str","indexOf","number","Number","isInteger","test","length","newline","i","retainLines","Math","min","j","_newline","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","withSource","queue","_maybeAddParen","_maybeIndent","append","_getIndent","parenPushNewlineState","cha","chaPost","slice","printed","pos","line","count","getCurrentLine","style","repeat","startTerminatorless","isLabel","endTerminatorless","state","node","parent","oldConcise","_compact","printMethod","type","ReferenceError","JSON","stringify","name","push","oldInAux","needsParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","isProgram","isFile","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","printAndIndentOnComments","leadingComments","printBlock","body","isEmptyStatement","_printComments","_getComments","printInnerComments","_node$innerComments","innerComments","printSequence","printList","items","commaSeparator","leading","lines","needs","needsWhitespaceBefore","needsWhitespaceAfter","trailingComments","skipNewLines","shouldPrintComment","ignore","add","start","isBlockComment","printNewLines","val","adjustMultilineComment","_comment$loc","offset","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","comments","inlinePureAnnotation","printAssertions","_node$assertions","assertions","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._printedCommentStarts = {};\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  }\n\n  token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state == null ? void 0 : state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes == null ? void 0 : nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    if (comment.start != null) {\n      if (this._printedCommentStarts[comment.start]) return;\n      this._printedCommentStarts[comment.start] = true;\n    }\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments == null ? void 0 : comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}"]},"metadata":{},"sourceType":"script"}